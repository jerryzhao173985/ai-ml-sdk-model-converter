From: svc_sdk <svc_sdk@arm.com>
Date: Fri Nov 14 00:00:00 2025
Subject: llvm-changes-for-model-converter-14-11-2025

diff --git a/mlir/include/mlir/Conversion/Passes.h b/mlir/include/mlir/Conversion/Passes.h
index 40d866ec7bf1..d1db147bed44 100644
--- a/mlir/include/mlir/Conversion/Passes.h
+++ b/mlir/include/mlir/Conversion/Passes.h
@@ -73,6 +73,8 @@
 #include "mlir/Conversion/TosaToLinalg/TosaToLinalg.h"
 #include "mlir/Conversion/TosaToMLProgram/TosaToMLProgram.h"
 #include "mlir/Conversion/TosaToSCF/TosaToSCF.h"
+#include "mlir/Conversion/TosaToSPIRV/TosaToSPIRV.h"
+#include "mlir/Conversion/TosaToSPIRV/ConvertTosaConstants.h"
 #include "mlir/Conversion/TosaToTensor/TosaToTensor.h"
 #include "mlir/Conversion/UBToLLVM/UBToLLVM.h"
 #include "mlir/Conversion/UBToSPIRV/UBToSPIRV.h"
diff --git a/mlir/include/mlir/Conversion/Passes.td b/mlir/include/mlir/Conversion/Passes.td
index 70e3e45c225d..203ed5e606c8 100644
--- a/mlir/include/mlir/Conversion/Passes.td
+++ b/mlir/include/mlir/Conversion/Passes.td
@@ -1318,6 +1318,38 @@ def TosaToSCFPass : Pass<"tosa-to-scf"> {
   }];
 }
 
+//===----------------------------------------------------------------------===//
+// TosaToSPIRV
+//===----------------------------------------------------------------------===//
+
+def TosaToSPIRV : Pass<"tosa-to-spirv"> {
+  let summary = "Lower TOSA to the SPIR-V dialect";
+  let dependentDialects = [
+    "spirv::SPIRVDialect",
+  ];
+  let description = [{
+    Pass that converts TOSA operations to the equivalent operations using the
+    operations in the SPIR-V dialect.
+  }];
+
+  let constructor = "tosa::createTosaToSPIRV()";
+}
+
+//===----------------------------------------------------------------------===//
+// ConvertTosaConstantsPass
+//===----------------------------------------------------------------------===//
+
+def ConvertTosaConstantsPass : Pass<"convert-tosa-constants-pass", "mlir::func::FuncOp"> {
+  let summary = "Convert TOSA constants to SPIR-V graph constants";
+
+  let description = [{
+    Pass that converts TOSA constants to SPIR-V graph constants in the
+    SPIR-V dialect.
+  }];
+
+  let constructor = "tosa::createConvertTosaConstantsPass()";
+}
+
 //===----------------------------------------------------------------------===//
 // TosaToTensor
 //===----------------------------------------------------------------------===//
diff --git a/mlir/include/mlir/Conversion/TosaToSPIRV/ConvertTosaConstants.h b/mlir/include/mlir/Conversion/TosaToSPIRV/ConvertTosaConstants.h
new file mode 100644
index 000000000000..c3dd512a90eb
--- /dev/null
+++ b/mlir/include/mlir/Conversion/TosaToSPIRV/ConvertTosaConstants.h
@@ -0,0 +1,34 @@
+//===-- TosaToSPIRV.h - TOSA to SPIR-V patterns -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// Pass to Convert Tosa Constants to SPIR-V graph constants.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef MLIR_CONVERSION_TOSATOSPIRV_CONVERTTOSACONSTANTS_H
+#define MLIR_CONVERSION_TOSATOSPIRV_CONVERTTOSACONSTANTS_H
+
+#include "mlir/Dialect/Func/IR/FuncOps.h"
+#include "mlir/Pass/Pass.h"
+
+namespace mlir {
+#define GEN_PASS_DEF_CONVERTTOSACONSTANTSPASS
+#include "mlir/Conversion/Passes.h.inc"
+
+namespace tosa {
+
+std::optional<uint32_t> getGraphId(Operation *op, const std::string &attrName);
+
+std::optional<uint32_t> getGraphIdForConst(Operation *op);
+
+std::unique_ptr<Pass> createConvertTosaConstantsPass();
+
+} // namespace tosa
+} // namespace mlir
+
+#endif // MLIR_CONVERSION_TOSATOSPIRV_CONVERTTOSACONSTANTS_H
diff --git a/mlir/include/mlir/Conversion/TosaToSPIRV/TosaToSPIRV.h b/mlir/include/mlir/Conversion/TosaToSPIRV/TosaToSPIRV.h
new file mode 100644
index 000000000000..20fb9ef11a42
--- /dev/null
+++ b/mlir/include/mlir/Conversion/TosaToSPIRV/TosaToSPIRV.h
@@ -0,0 +1,36 @@
+//===-- TosaToSPIRV.h - TOSA to SPIR-V patterns -----------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// Provides patterns to convert Tosa dialect to SPIR-V dialect.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef MLIR_CONVERSION_TOSATOSPIRV_TOSATOSPIRV_H
+#define MLIR_CONVERSION_TOSATOSPIRV_TOSATOSPIRV_H
+
+#include "mlir/Dialect/SPIRV/Transforms/SPIRVConversion.h"
+#include "mlir/Pass/Pass.h"
+
+namespace mlir {
+
+#define GEN_PASS_DECL_TOSATOSPIRV
+#include "mlir/Conversion/Passes.h.inc"
+
+namespace tosa {
+
+std::unique_ptr<Pass> createTosaToSPIRV(bool analysis = false);
+
+void populateTosaToSPIRVConversionPatterns(SPIRVTypeConverter &typeConverter,
+                                           RewritePatternSet &patterns);
+void populateTosaToSPIRVOpsConversionPatterns(SPIRVTypeConverter &typeConverter,
+                                              RewritePatternSet &patterns);
+
+} // namespace tosa
+} // namespace mlir
+
+#endif // MLIR_CONVERSION_TOSATOSPIRV_TOSATOSPIRV_H
diff --git a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td
index b628f1a3f7b2..776510927a8f 100644
--- a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td
+++ b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td
@@ -1343,7 +1343,7 @@ def SPIRV_C_StorageTensorArrayNonUniformIndexingEXT     : I32EnumAttrCase<"Stora
   ];
 }
 def SPIRV_C_GraphARM                                    : I32EnumAttrCase<"GraphARM", 4191> {
-  list<I32EnumAttrCase> implies = [SPIRV_C_TensorsARM];
+  list<I32EnumAttrCase> implies = [SPIRV_C_TensorsARM, SPIRV_C_Shader, SPIRV_C_VulkanMemoryModel];
   list<Availability> availability = [
     Extension<[SPV_ARM_graph]>
   ];
@@ -4233,6 +4233,7 @@ def SPIRV_IsTensorArmType : CPred<"::llvm::isa<::mlir::spirv::TensorArmType>($_s
 def SPIRV_Void : TypeAlias<NoneType, "void">;
 def SPIRV_Bool : TypeAlias<I1, "bool">;
 def SPIRV_Integer : AnyIntOfWidths<[8, 16, 32, 64]>;
+def SPIRV_Int8 : TypeAlias<I8, "Int8">;
 def SPIRV_Int16 : TypeAlias<I16, "Int16">;
 def SPIRV_Int32 : TypeAlias<I32, "Int32">;
 def SPIRV_Float32 : TypeAlias<F32, "Float32">;
diff --git a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVGraphOps.td b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVGraphOps.td
index 69551a9c0b97..f73e712a41a9 100644
--- a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVGraphOps.td
+++ b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVGraphOps.td
@@ -14,6 +14,7 @@
 #define MLIR_DIALECT_SPIRV_IR_GRAPH_OPS
 
 include "mlir/Dialect/SPIRV/IR/SPIRVBase.td"
+include "mlir/Dialect/SPIRV/IR/SPIRVTosaTypes.td"
 include "mlir/Interfaces/CallInterfaces.td"
 include "mlir/Interfaces/SideEffectInterfaces.td"
 include "mlir/Interfaces/FunctionInterfaces.td"
diff --git a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVOps.td b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVOps.td
index 96ef035eda37..3ef9699154cd 100644
--- a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVOps.td
+++ b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVOps.td
@@ -45,6 +45,7 @@ include "mlir/Dialect/SPIRV/IR/SPIRVNonUniformOps.td"
 include "mlir/Dialect/SPIRV/IR/SPIRVPrimitiveOps.td"
 include "mlir/Dialect/SPIRV/IR/SPIRVCLOps.td"
 include "mlir/Dialect/SPIRV/IR/SPIRVStructureOps.td"
+include "mlir/Dialect/SPIRV/IR/SPIRVTosaOps.td"
 include "mlir/Interfaces/SideEffectInterfaces.td"
 
 #endif // MLIR_DIALECT_SPIRV_IR_OPS
diff --git a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTosaOps.td b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTosaOps.td
new file mode 100644
index 000000000000..c7d468be9e81
--- /dev/null
+++ b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTosaOps.td
@@ -0,0 +1,1806 @@
+//===- SPIRVTosaOps.td - TOSA extended insts spec file -----*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This is the op definition spec of TOSA extension ops.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef MLIR_DIALECT_SPIRV_IR_TOSA_OPS
+#define MLIR_DIALECT_SPIRV_IR_TOSA_OPS
+
+include "mlir/Dialect/SPIRV/IR/SPIRVBase.td"
+include "mlir/Dialect/SPIRV/IR/SPIRVGraphOps.td"
+include "mlir/Dialect/SPIRV/IR/SPIRVTosaTypes.td"
+include "mlir/Interfaces/SideEffectInterfaces.td"
+
+//===----------------------------------------------------------------------===//
+// SPIR-V TOSA opcode specification.
+//===----------------------------------------------------------------------===//
+
+// Base class for all TOSA ops.
+class SPIRV_TosaOp<string mnemonic, int opcode, list<Trait> traits = []> :
+  SPIRV_ExtInstOp<mnemonic, "Tosa", "TOSA.001000.1", opcode, !listconcat(traits, [InGraphScope])> {
+
+  let availability = [
+    MinVersion<SPIRV_V_1_5>,
+    MaxVersion<SPIRV_V_1_6>,
+    Extension<[SPV_ARM_graph]>,
+    Capability<[SPIRV_C_GraphARM]>
+  ];
+}
+
+
+def SPIRV_TosaArgMaxOp : SPIRV_TosaOp<"ArgMax", 0, [Pure]> {
+ let summary = "ArgMax - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_argmax
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $axis,
+    SPIRV_Int32: $nan_mode,
+    SPIRV_TosaNumerical_TensorArm1DTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo5D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaAvgPool2DOp : SPIRV_TosaOp<"AvgPool2D", 1, [Pure]> {
+ let summary = "AvgPool2D - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_avg_pool2d
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32_1DTensorArmOfLength2: $kernel,
+    SPIRV_Int32_1DTensorArmOfLength2: $stride,
+    SPIRV_Int32_1DTensorArmOfLength4: $pad,
+    SPIRV_Int32: $acc_type,
+    SPIRV_TosaNumerical_TensorArm4D: $input,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $input_zp,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $output_zp
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm4D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaConv2DOp : SPIRV_TosaOp<"Conv2D", 2, [Pure]> {
+ let summary = "Conv2D - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_conv2d
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32_1DTensorArmOfLength4: $pad,
+    SPIRV_Int32_1DTensorArmOfLength2: $stride,
+    SPIRV_Int32_1DTensorArmOfLength2: $dilation,
+    SPIRV_Int32: $acc_type,
+    SPIRV_Bool: $local_bound,
+    SPIRV_TosaNumerical_TensorArm4D: $input,
+    SPIRV_TosaNumerical_TensorArm4D: $weight,
+    SPIRV_TosaNumerical_TensorArm1D: $bias,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $input_zp,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $weight_zp
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm4D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaConv3DOp : SPIRV_TosaOp<"Conv3D", 3, [Pure]> {
+ let summary = "Conv3D - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_conv3d
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32_1DTensorArmOfLength6: $pad,
+    SPIRV_Int32_1DTensorArmOfLength3: $stride,
+    SPIRV_Int32_1DTensorArmOfLength3: $dilation,
+    SPIRV_Int32: $acc_type,
+    SPIRV_Bool: $local_bound,
+    SPIRV_TosaNumerical_TensorArm5D: $input,
+    SPIRV_TosaNumerical_TensorArm5D: $weight,
+    SPIRV_TosaNumerical_TensorArm1D: $bias,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $input_zp,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $weight_zp
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm5D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaDepthwiseConv2DOp : SPIRV_TosaOp<"DepthwiseConv2D", 4, [Pure]> {
+ let summary = "DepthwiseConv2D - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_depthwise_conv2d
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32_1DTensorArmOfLength4: $pad,
+    SPIRV_Int32_1DTensorArmOfLength2: $stride,
+    SPIRV_Int32_1DTensorArmOfLength2: $dilation,
+    SPIRV_Int32: $acc_type,
+    SPIRV_Bool: $local_bound,
+    SPIRV_TosaNumerical_TensorArm4D: $input,
+    SPIRV_TosaNumerical_TensorArm4D: $weight,
+    SPIRV_TosaNumerical_TensorArm1D: $bias,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $input_zp,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $weight_zp
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm4D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaFFT2DOp : SPIRV_TosaOp<"FFT2D", 5, [Pure]> {
+ let summary = "FFT2D - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_fft2d
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Bool: $inverse,
+    SPIRV_Bool: $local_bound,
+    SPIRV_TosaFloat_TensorArm3D: $input_real,
+    SPIRV_TosaFloat_TensorArm3D: $input_imag
+  );
+
+
+  let results = (outs
+    SPIRV_Struct_2_TosaFloat_TensorArm3D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaMatMulOp : SPIRV_TosaOp<"MatMul", 6, [Pure]> {
+ let summary = "MatMul - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_matmul
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArm3D: $A,
+    SPIRV_TosaNumerical_TensorArm3D: $B,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $A_zp,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $B_zp
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm3D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaMaxPool2DOp : SPIRV_TosaOp<"MaxPool2D", 7, [Pure]> {
+ let summary = "MaxPool2D - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_max_pool2d
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32_1DTensorArmOfLength2: $kernel,
+    SPIRV_Int32_1DTensorArmOfLength2: $stride,
+    SPIRV_Int32_1DTensorArmOfLength4: $pad,
+    SPIRV_Int32: $nan_mode,
+    SPIRV_TosaNumerical_TensorArm4D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm4D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaRFFT2DOp : SPIRV_TosaOp<"RFFT2D", 8, [Pure]> {
+ let summary = "RFFT2D - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_rfft2d
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Bool: $local_bound,
+    SPIRV_TosaFloat_TensorArm3D: $input_real
+  );
+
+
+  let results = (outs
+    SPIRV_Struct_2_TosaFloat_TensorArm3D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaTransposeConv2DOp : SPIRV_TosaOp<"TransposeConv2D", 9, [Pure]> {
+ let summary = "TransposeConv2D - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_transpose_conv2d
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32_1DTensorArmOfLength4: $out_pad,
+    SPIRV_Int32_1DTensorArmOfLength2: $stride,
+    SPIRV_Int32: $acc_type,
+    SPIRV_Bool: $local_bound,
+    SPIRV_TosaNumerical_TensorArm4D: $input,
+    SPIRV_TosaNumerical_TensorArm4D: $weight,
+    SPIRV_TosaNumerical_TensorArm1D: $bias,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $input_zp,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $weight_zp
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm4D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaClampOp : SPIRV_TosaOp<"Clamp", 10, [Pure]> {
+ let summary = "Clamp - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_clamp
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical: $min_val,
+    SPIRV_TosaNumerical: $max_val,
+    SPIRV_Int32: $nan_mode,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaErfOp : SPIRV_TosaOp<"Erf", 11, [Pure]> {
+ let summary = "Erf - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_erf
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaSigmoidOp : SPIRV_TosaOp<"Sigmoid", 12, [Pure]> {
+ let summary = "Sigmoid - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_sigmoid
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaTanhOp : SPIRV_TosaOp<"Tanh", 13, [Pure]> {
+ let summary = "Tanh - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_tanh
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaAddOp : SPIRV_TosaOp<"Add", 14, [Pure]> {
+ let summary = "Add - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_add
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input1,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaArithmeticRightShiftOp : SPIRV_TosaOp<"ArithmeticRightShift", 15, [Pure]> {
+ let summary = "ArithmeticRightShift - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_arithmetic_right_shift
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Bool: $round,
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input1,
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaBitwiseAndOp : SPIRV_TosaOp<"BitwiseAnd", 16, [Pure]> {
+ let summary = "BitwiseAnd - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_bitwise_and
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input1,
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaBitwiseOrOp : SPIRV_TosaOp<"BitwiseOr", 17, [Pure]> {
+ let summary = "BitwiseOr - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_bitwise_or
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input1,
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaBitwiseXorOp : SPIRV_TosaOp<"BitwiseXor", 18, [Pure]> {
+ let summary = "BitwiseXor - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_bitwise_xor
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input1,
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaIntDivOp : SPIRV_TosaOp<"IntDiv", 19, [Pure]> {
+ let summary = "IntDiv - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_intdiv
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input1,
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaLogicalAndOp : SPIRV_TosaOp<"LogicalAnd", 20, [Pure]> {
+ let summary = "LogicalAnd - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_and
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Bool_TensorArmUpTo6D: $input1,
+    SPIRV_Bool_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_Bool_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaLogicalLeftShiftOp : SPIRV_TosaOp<"LogicalLeftShift", 21, [Pure]> {
+ let summary = "LogicalLeftShift - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_left_shift
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input1,
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaLogicalRightShiftOp : SPIRV_TosaOp<"LogicalRightShift", 22, [Pure]> {
+ let summary = "LogicalRightShift - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_right_shift
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input1,
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaLogicalOrOp : SPIRV_TosaOp<"LogicalOr", 23, [Pure]> {
+ let summary = "LogicalOr - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_or
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Bool_TensorArmUpTo6D: $input1,
+    SPIRV_Bool_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_Bool_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaLogicalXorOp : SPIRV_TosaOp<"LogicalXor", 24, [Pure]> {
+ let summary = "LogicalXor - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_xor
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Bool_TensorArmUpTo6D: $input1,
+    SPIRV_Bool_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_Bool_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaMaximumOp : SPIRV_TosaOp<"Maximum", 25, [Pure]> {
+ let summary = "Maximum - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_maximum
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $nan_mode,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input1,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaMinimumOp : SPIRV_TosaOp<"Minimum", 26, [Pure]> {
+ let summary = "Minimum - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_minimum
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $nan_mode,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input1,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaMulOp : SPIRV_TosaOp<"Mul", 27, [Pure]> {
+ let summary = "Mul - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_mul
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input1,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input2,
+    SPIRV_Int8_1DTensorArmOfLength1: $shift
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaPowOp : SPIRV_TosaOp<"Pow", 28, [Pure]> {
+ let summary = "Pow - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_pow
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input1,
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaSubOp : SPIRV_TosaOp<"Sub", 29, [Pure]> {
+ let summary = "Sub - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_sub
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input1,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaTableOp : SPIRV_TosaOp<"Table", 30, [Pure]> {
+ let summary = "Table - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_table
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input1,
+    SPIRV_TosaInteger_TensorArm1D: $table
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaAbsOp : SPIRV_TosaOp<"Abs", 31, [Pure]> {
+ let summary = "Abs - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_abs
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaBitwiseNotOp : SPIRV_TosaOp<"BitwiseNot", 32, [Pure]> {
+ let summary = "BitwiseNot - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_bitwise_not
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaCeilOp : SPIRV_TosaOp<"Ceil", 33, [Pure]> {
+ let summary = "Ceil - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_ceil
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaClzOp : SPIRV_TosaOp<"Clz", 34, [Pure]> {
+ let summary = "Clz - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_clz
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaCosOp : SPIRV_TosaOp<"Cos", 35, [Pure]> {
+ let summary = "Cos - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_cos
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaExpOp : SPIRV_TosaOp<"Exp", 36, [Pure]> {
+ let summary = "Exp - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_exp
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaFloorOp : SPIRV_TosaOp<"Floor", 37, [Pure]> {
+ let summary = "Floor - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_floor
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaLogOp : SPIRV_TosaOp<"Log", 38, [Pure]> {
+ let summary = "Log - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_log
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaLogicalNotOp : SPIRV_TosaOp<"LogicalNot", 39, [Pure]> {
+ let summary = "LogicalNot - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_not
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Bool_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_Bool_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaNegateOp : SPIRV_TosaOp<"Negate", 40, [Pure]> {
+ let summary = "Negate - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_negate
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input1,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $input1_zp,
+    SPIRV_TosaNumerical_1DTensorArmOfLength1: $output_zp
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaReciprocalOp : SPIRV_TosaOp<"Reciprocal", 41, [Pure]> {
+ let summary = "Reciprocal - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reciprocal
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaRsqrtOp : SPIRV_TosaOp<"Rsqrt", 42, [Pure]> {
+ let summary = "Rsqrt - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_rsqrt
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaSinOp : SPIRV_TosaOp<"Sin", 43, [Pure]> {
+ let summary = "Sin - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_sin
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaFloat_TensorArmUpTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaSelectOp : SPIRV_TosaOp<"Select", 44, [Pure]> {
+ let summary = "Select - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_select
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Bool_TensorArmUpTo6D: $input1,
+    SPIRV_TosaAny_TensorArmUpTo6D: $input2,
+    SPIRV_TosaAny_TensorArmUpTo6D: $input3
+  );
+
+
+  let results = (outs
+    SPIRV_TosaAny_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaEqualOp : SPIRV_TosaOp<"Equal", 45, [Pure]> {
+ let summary = "Equal - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_equal
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input1,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_Bool_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaGreaterOp : SPIRV_TosaOp<"Greater", 46, [Pure]> {
+ let summary = "Greater - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_greater
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input1,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_Bool_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaGreaterEqualOp : SPIRV_TosaOp<"GreaterEqual", 47, [Pure]> {
+ let summary = "GreaterEqual - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_greater_equal
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input1,
+    SPIRV_TosaNumerical_TensorArmUpTo6D: $input2
+  );
+
+
+  let results = (outs
+    SPIRV_Bool_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaReduceAllOp : SPIRV_TosaOp<"ReduceAll", 48, [Pure]> {
+ let summary = "ReduceAll - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_all
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $axis,
+    SPIRV_Bool_TensorArm1DTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_Bool_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaReduceAnyOp : SPIRV_TosaOp<"ReduceAny", 49, [Pure]> {
+ let summary = "ReduceAny - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_any
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $axis,
+    SPIRV_Bool_TensorArm1DTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_Bool_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaReduceMaxOp : SPIRV_TosaOp<"ReduceMax", 50, [Pure]> {
+ let summary = "ReduceMax - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_max
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $axis,
+    SPIRV_Int32: $nan_mode,
+    SPIRV_TosaNumerical_TensorArm1DTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaReduceMinOp : SPIRV_TosaOp<"ReduceMin", 51, [Pure]> {
+ let summary = "ReduceMin - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_min
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $axis,
+    SPIRV_Int32: $nan_mode,
+    SPIRV_TosaNumerical_TensorArm1DTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaReduceProductOp : SPIRV_TosaOp<"ReduceProduct", 52, [Pure]> {
+ let summary = "ReduceProduct - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_product
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $axis,
+    SPIRV_TosaFloat_TensorArm1DTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaFloat_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaReduceSumOp : SPIRV_TosaOp<"ReduceSum", 53, [Pure]> {
+ let summary = "ReduceSum - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_sum
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $axis,
+    SPIRV_TosaNumerical_TensorArm1DTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaConcatOp : SPIRV_TosaOp<"Concat", 54, [Pure]> {
+ let summary = "Concat - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_concat
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $axis,
+    Variadic<SPIRV_TosaAny_TensorArm1DTo6D>: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaAny_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaPadOp : SPIRV_TosaOp<"Pad", 55, [Pure]> {
+ let summary = "Pad - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_pad
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaAny_TensorArm1DTo6D: $input1,
+    SPIRV_Int32_1DTensorArmOfEvenLength2To12: $padding,
+    SPIRV_TosaAny_1DTensorArmOfLength1: $pad_const
+  );
+
+
+  let results = (outs
+    SPIRV_TosaAny_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaReshapeOp : SPIRV_TosaOp<"Reshape", 56, [Pure]> {
+ let summary = "Reshape - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reshape
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaAny_TensorArmUpTo6D: $input1,
+    SPIRV_Int32_1DTensorArmOfLength1To6: $shape
+  );
+
+
+  let results = (outs
+    SPIRV_TosaAny_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaReverseOp : SPIRV_TosaOp<"Reverse", 57, [Pure]> {
+ let summary = "Reverse - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reverse
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $axis,
+    SPIRV_TosaAny_TensorArm1DTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaAny_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaSliceOp : SPIRV_TosaOp<"Slice", 58, [Pure]> {
+ let summary = "Slice - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_slice
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaAny_TensorArm1DTo6D: $input1,
+    SPIRV_Int32_1DTensorArmOfLength1To6: $start,
+    SPIRV_Int32_1DTensorArmOfLength1To6: $size
+  );
+
+
+  let results = (outs
+    SPIRV_TosaAny_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaTileOp : SPIRV_TosaOp<"Tile", 59, [Pure]> {
+ let summary = "Tile - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_tile
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaAny_TensorArm1DTo6D: $input1,
+    SPIRV_Int32_1DTensorArmOfLength1To6: $multiples
+  );
+
+
+  let results = (outs
+    SPIRV_TosaAny_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaTransposeOp : SPIRV_TosaOp<"Transpose", 60, [Pure]> {
+ let summary = "Transpose - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_transpose
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32_1DTensorArmOfLength1To6: $perms,
+    SPIRV_TosaAny_TensorArm1DTo6D: $input1
+  );
+
+
+  let results = (outs
+    SPIRV_TosaAny_TensorArm1DTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaGatherOp : SPIRV_TosaOp<"Gather", 61, [Pure]> {
+ let summary = "Gather - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_gather
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArm3D: $values,
+    SPIRV_Int32_TensorArm2D: $indices
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm3D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaScatterOp : SPIRV_TosaOp<"Scatter", 62, [Pure]> {
+ let summary = "Scatter - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_scatter
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaNumerical_TensorArm3D: $values_in,
+    SPIRV_Int32_TensorArm2D: $indices,
+    SPIRV_TosaNumerical_TensorArm3D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm3D: $values_out
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaResizeOp : SPIRV_TosaOp<"Resize", 63, [Pure]> {
+ let summary = "Resize - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_resize
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Int32: $mode,
+    SPIRV_TosaNumerical_TensorArm4D: $input,
+    SPIRV_Int32_1DTensorArmOfLength4: $scale,
+    SPIRV_Int32_1DTensorArmOfLength2: $offset,
+    SPIRV_Int32_1DTensorArmOfLength2: $border
+  );
+
+
+  let results = (outs
+    SPIRV_TosaNumerical_TensorArm4D: $output
+  );
+
+  let hasVerifier = 0;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaCastOp : SPIRV_TosaOp<"Cast", 64, [Pure]> {
+ let summary = "Cast - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_cast
+  }];
+
+
+  let arguments = (ins
+    SPIRV_TosaAny_TensorArmUpTo6D: $input
+  );
+
+
+  let results = (outs
+    SPIRV_TosaAny_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+def SPIRV_TosaRescaleOp : SPIRV_TosaOp<"Rescale", 65, [Pure]> {
+ let summary = "Rescale - TOSA extended instruction set 001000.1";
+
+  let description = [{
+    https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_rescale
+  }];
+
+
+  let arguments = (ins
+    SPIRV_Bool: $scale32,
+    SPIRV_Int32: $rounding_mode,
+    SPIRV_Bool: $per_channel,
+    SPIRV_Bool: $input_unsigned,
+    SPIRV_Bool: $output_unsigned,
+    SPIRV_TosaInteger_TensorArmUpTo6D: $input,
+    SPIRV_Int16OrInt32_TensorArm1D: $multiplier,
+    SPIRV_Int8_TensorArm1D: $shift,
+    SPIRV_TosaInteger_1DTensorArmOfLength1: $input_zp,
+    SPIRV_TosaInteger_1DTensorArmOfLength1: $output_zp
+  );
+
+
+  let results = (outs
+    SPIRV_TosaInteger_TensorArmUpTo6D: $output
+  );
+
+  let hasVerifier = 1;
+
+  let assemblyFormat = [{
+    operands attr-dict `:` `(` type(operands) `)` `->` type(results)
+  }];
+}
+
+
+#endif // MLIR_DIALECT_SPIRV_IR_TOSA_OPS
diff --git a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTosaTypes.td b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTosaTypes.td
new file mode 100644
index 000000000000..c9e23b60470b
--- /dev/null
+++ b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTosaTypes.td
@@ -0,0 +1,97 @@
+//===- SPIRVTosaTypes.td - Tosa Types insts spec file ----*- tablegen -*-=//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This specifies Tosa types used by the Graph Extension and Tosa Ops.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef MLIR_DIALECT_SPIRV_IR_TOSA_TYPES
+#define MLIR_DIALECT_SPIRV_IR_TOSA_TYPES
+
+include "mlir/Dialect/SPIRV/IR/SPIRVBase.td"
+
+def SPIRV_TosaInteger : AnyIntOfWidths<[8, 16, 32, 64]>;
+def SPIRV_TosaFloat : AnyTypeOf<[BF16, SPIRV_Float16or32]>;
+def SPIRV_TosaNumerical : AnyTypeOf<[SPIRV_TosaInteger, SPIRV_TosaFloat]>;
+def SPIRV_TosaAny : AnyTypeOf<[SPIRV_TosaNumerical, SPIRV_Bool]>;
+
+// TensorARM type
+
+class RankedTensorArmOf<list<Type> allowedTypes, list<Pred> preds = [],
+                     string summary = "ranked tensorArm">
+  : ShapedContainerType<
+      allowedTypes, And<!listconcat([SPIRV_IsTensorArmType], preds)>,
+      summary, "::mlir::spirv::TensorArmType">;
+
+class TensorArmRankOf<list<Type> allowedTypes, list<int> ranks>
+  : RankedTensorArmOf<allowedTypes,
+      [HasAnyRankOfPred<ranks>],
+      !interleave(!foreach(rank, ranks, rank # "D"), "/") # " tensorArm">;
+
+def SPIRV_Int8_TensorArm1D : TensorArmRankOf<[SPIRV_Int8], [1]>;
+def SPIRV_Int16OrInt32_TensorArm1D : TensorArmRankOf<[SPIRV_Int16, SPIRV_Int32], [1]>;
+def SPIRV_Int32_TensorArm2D : TensorArmRankOf<[SPIRV_Int32], [2]>;
+def SPIRV_TosaFloat_TensorArm3D: TensorArmRankOf<[SPIRV_TosaFloat], [3]>;
+def SPIRV_TosaInteger_TensorArm1D : TensorArmRankOf<[SPIRV_TosaInteger], [1]>;
+def SPIRV_TosaNumerical_TensorArm1D : TensorArmRankOf<[SPIRV_TosaNumerical], [1]>;
+def SPIRV_TosaNumerical_TensorArm3D : TensorArmRankOf<[SPIRV_TosaNumerical], [3]>;
+def SPIRV_TosaNumerical_TensorArm4D : TensorArmRankOf<[SPIRV_TosaNumerical], [4]>;
+def SPIRV_TosaNumerical_TensorArm5D : TensorArmRankOf<[SPIRV_TosaNumerical], [5]>;
+
+def SPIRV_TosaAny_TensorArmUpTo6D : TensorArmRankOf<[SPIRV_TosaAny], [0, 1, 2, 3, 4, 5, 6]>;
+def SPIRV_TosaAny_TensorArm1DTo6D : TensorArmRankOf<[SPIRV_TosaAny], [1, 2, 3, 4, 5, 6]>;
+def SPIRV_TosaNumerical_TensorArmUpTo6D : TensorArmRankOf<[SPIRV_TosaNumerical], [0, 1, 2, 3, 4, 5, 6]>;
+def SPIRV_TosaNumerical_TensorArm1DTo6D : TensorArmRankOf<[SPIRV_TosaNumerical], [1, 2, 3, 4, 5, 6]>;
+def SPIRV_TosaInteger_TensorArmUpTo5D : TensorArmRankOf<[SPIRV_TosaInteger], [0, 1, 2, 3, 4, 5]>;
+def SPIRV_TosaInteger_TensorArmUpTo6D : TensorArmRankOf<[SPIRV_TosaInteger], [0, 1, 2, 3, 4, 5, 6]>;
+def SPIRV_TosaFloat_TensorArmUpTo6D : TensorArmRankOf<[SPIRV_TosaFloat], [0, 1, 2, 3, 4, 5, 6]>;
+def SPIRV_TosaFloat_TensorArm1DTo6D : TensorArmRankOf<[SPIRV_TosaFloat], [1, 2, 3, 4, 5, 6]>;
+def SPIRV_Bool_TensorArmUpTo6D : TensorArmRankOf<[SPIRV_Bool], [0, 1, 2, 3, 4, 5, 6]>;
+def SPIRV_Bool_TensorArm1DTo6D : TensorArmRankOf<[SPIRV_Bool], [1, 2, 3, 4, 5, 6]>;
+
+class Is1DTensorArmOfLength<list<int> allowedLengths> :
+  And<[HasAnyRankOfPred<[1]>,
+       Or<!foreach(allowedlength, allowedLengths,
+                   CPred<[{::llvm::cast<::mlir::spirv::TensorArmType>($_self).getShape()[0] == }]
+                         # allowedlength>)>]>;
+
+class SPIRV_1DTensorArmOfLengthAndType<list<int> allowedLengths, list<Type> allowedTypes> :
+  ContainerType<AnyTypeOf<allowedTypes>, Is1DTensorArmOfLength<allowedLengths>,
+    "::llvm::cast<::mlir::spirv::TensorArmType>($_self).getElementType()",
+    "rank 1 tensorArm of length " # !interleave(allowedLengths, "/"),
+    "::mlir::spirv::TensorArmType">;
+
+def SPIRV_Int32_1DTensorArmOfLength2 : SPIRV_1DTensorArmOfLengthAndType<[2], [SPIRV_Int32]>;
+def SPIRV_Int32_1DTensorArmOfLength3 : SPIRV_1DTensorArmOfLengthAndType<[3], [SPIRV_Int32]>;
+def SPIRV_Int32_1DTensorArmOfLength4 : SPIRV_1DTensorArmOfLengthAndType<[4], [SPIRV_Int32]>;
+def SPIRV_Int32_1DTensorArmOfLength6 : SPIRV_1DTensorArmOfLengthAndType<[6], [SPIRV_Int32]>;
+
+def SPIRV_Int32_1DTensorArmOfLength1To6 : SPIRV_1DTensorArmOfLengthAndType<[1,2,3,4,5,6], [SPIRV_Int32]>;
+def SPIRV_Int32_1DTensorArmOfEvenLength2To12 : SPIRV_1DTensorArmOfLengthAndType<[2,4,6,8,10,12], [SPIRV_Int32]>;
+
+def SPIRV_Int8_1DTensorArmOfLength1 : SPIRV_1DTensorArmOfLengthAndType<[1], [SPIRV_Int8]>;
+def SPIRV_TosaInteger_1DTensorArmOfLength1 : SPIRV_1DTensorArmOfLengthAndType<[1], [SPIRV_TosaInteger]>;
+def SPIRV_TosaNumerical_1DTensorArmOfLength1 : SPIRV_1DTensorArmOfLengthAndType<[1], [SPIRV_TosaNumerical]>;
+def SPIRV_TosaAny_1DTensorArmOfLength1 : SPIRV_1DTensorArmOfLengthAndType<[1], [SPIRV_TosaAny]>;
+
+// Struct type
+
+class IsStructOfLengthPred<int allowedLength> :
+  And<[SPIRV_IsStructType,
+      CPred<[{::llvm::cast<::mlir::spirv::StructType>($_self).getNumElements()
+              == }]
+            # allowedLength>]>;
+
+class IsStructOfLengthAndType<int allowedLength, list<Type> allowedTypes>
+    : MixedContainerType<AnyTypeOf<allowedTypes>, IsStructOfLengthPred<allowedLength>,
+                         "::llvm::cast<::mlir::spirv::StructType>($_self).getElementTypes()",
+                         "Struct">;
+
+def SPIRV_Struct_2_TosaFloat_TensorArm3D : IsStructOfLengthAndType<2, [SPIRV_TosaFloat_TensorArm3D]>;
+
+#endif // MLIR_DIALECT_SPIRV_IR_TOSA_TYPES
diff --git a/mlir/lib/Conversion/CMakeLists.txt b/mlir/lib/Conversion/CMakeLists.txt
index bebf1b8fff3f..4cce4ae0ec7e 100644
--- a/mlir/lib/Conversion/CMakeLists.txt
+++ b/mlir/lib/Conversion/CMakeLists.txt
@@ -67,6 +67,7 @@ add_subdirectory(TosaToArith)
 add_subdirectory(TosaToLinalg)
 add_subdirectory(TosaToMLProgram)
 add_subdirectory(TosaToSCF)
+add_subdirectory(TosaToSPIRV)
 add_subdirectory(TosaToTensor)
 add_subdirectory(UBToLLVM)
 add_subdirectory(UBToSPIRV)
diff --git a/mlir/lib/Conversion/TosaToSPIRV/CMakeLists.txt b/mlir/lib/Conversion/TosaToSPIRV/CMakeLists.txt
new file mode 100644
index 000000000000..75b534ff8973
--- /dev/null
+++ b/mlir/lib/Conversion/TosaToSPIRV/CMakeLists.txt
@@ -0,0 +1,23 @@
+add_mlir_conversion_library(MLIRTosaToSPIRV
+  TosaToSPIRV.cpp
+  TosaToSPIRVOps.cpp
+  TosaToSPIRVPass.cpp
+  ConvertTosaConstants.cpp
+  # FIXME: Avoid linking a share lib by compiling in the single cpp file needed
+  ${MLIR_MAIN_SRC_DIR}/lib/ExecutionEngine/Float16bits.cpp
+
+  ADDITIONAL_HEADER_DIRS
+  ${MLIR_MAIN_INCLUDE_DIR}/mlir/Dialect/Tosa
+  ${MLIR_MAIN_INCLUDE_DIR}/mlir/IR
+
+  DEPENDS
+  MLIRConversionPassIncGen
+
+  LINK_LIBS PUBLIC
+  MLIRSPIRVDialect
+  MLIRIR
+  MLIRPass
+  MLIRTosaDialect
+  MLIRTosaTransforms
+  MLIRSupport
+)
diff --git a/mlir/lib/Conversion/TosaToSPIRV/ConvertTosaConstants.cpp b/mlir/lib/Conversion/TosaToSPIRV/ConvertTosaConstants.cpp
new file mode 100644
index 000000000000..02173446b9c5
--- /dev/null
+++ b/mlir/lib/Conversion/TosaToSPIRV/ConvertTosaConstants.cpp
@@ -0,0 +1,214 @@
+//===- ConvertTosaConstants.cpp - Tosa constant to SPIR-V constant pass ---===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements pass to convert Tosa dialect constants to SPIRV dialect
+// constants.
+//
+//===----------------------------------------------------------------------===//
+
+#include "mlir/Dialect/Func/IR/FuncOps.h"
+#include "mlir/Dialect/Tosa/IR/TosaOps.h"
+#include "mlir/Dialect/Tosa/Transforms/Passes.h"
+#include "mlir/IR/TypeUtilities.h"
+#include "mlir/Pass/Pass.h"
+#include "mlir/Pass/PassManager.h"
+
+#include <unordered_map>
+#include <vector>
+
+namespace mlir {
+#define GEN_PASS_DEF_CONVERTTOSACONSTANTSPASS
+#include "mlir/Conversion/Passes.h.inc"
+
+namespace tosa {
+
+static constexpr uint32_t SPIRV_CONSTANT_MAX_SIZE_FOR_TOSA_CONST = 16;
+static constexpr uint32_t SPIRV_CONSTANT_MAX_SIZE_FOR_TOSA_CONST_SHAPE = 32;
+
+static constexpr llvm::StringLiteral graphConstAttrName =
+    "spirv_graph_constant_id";
+
+std::optional<uint32_t> getGraphId(Operation *op,
+                                   const llvm::StringRef attrName) {
+  if (auto attr = op->getAttrOfType<IntegerAttr>(attrName)) {
+    return static_cast<uint32_t>(attr.getInt());
+  }
+  return std::nullopt;
+}
+
+std::optional<uint32_t> getGraphIdForConst(Operation *op) {
+  return getGraphId(op, graphConstAttrName);
+}
+
+void setGraphIdForConst(Operation *op, uint32_t id) {
+  const Type tI32 = IntegerType::get(op->getContext(), 32);
+  op->setAttr(graphConstAttrName, IntegerAttr::get(tI32, id));
+}
+
+bool isOpGraphConstantARM(Operation *op) {
+  assert((isa<tosa::ConstOp>(op) || isa<tosa::ConstShapeOp>(op)) &&
+         "Operation is not a tosa.const or tosa.const_shape");
+
+  ElementsAttr valueAttr;
+  if (auto constOp = dyn_cast_or_null<tosa::ConstOp>(op)) {
+    valueAttr = constOp.getValuesAttr();
+  } else if (auto constShapeOp = dyn_cast_or_null<tosa::ConstShapeOp>(op)) {
+    valueAttr = constShapeOp.getValuesAttr();
+  }
+
+  assert(valueAttr && "Failed to get value attribute");
+
+  uint32_t constantSize = 0;
+  if (auto elemAttr = dyn_cast_or_null<ElementsAttr>(valueAttr)) {
+    if (elemAttr.getShapedType().getRank() > 1) {
+      return true;
+    }
+    constantSize = elemAttr.size();
+  } else if (auto denseArrayAttr =
+                 dyn_cast_or_null<DenseArrayAttr>(valueAttr)) {
+    constantSize = denseArrayAttr.size();
+  }
+
+  uint32_t maxSize = isa<tosa::ConstOp>(op)
+                         ? SPIRV_CONSTANT_MAX_SIZE_FOR_TOSA_CONST
+                         : SPIRV_CONSTANT_MAX_SIZE_FOR_TOSA_CONST_SHAPE;
+
+  return constantSize > maxSize;
+}
+
+class OpInfo {
+public:
+  OpInfo(Operation &op, int32_t use_count) : _op(op), _use_count(use_count) {}
+
+  void addUseCount() { _use_count++; }
+  int32_t getUseCount() const { return _use_count; }
+  Operation &getOp() const { return _op; }
+
+private:
+  Operation &_op;
+  int32_t _use_count;
+};
+
+class ConvertTosaConstantsPass
+    : public impl::ConvertTosaConstantsPassBase<ConvertTosaConstantsPass> {
+public:
+  void runOnOperation() override {
+    if (ConvertTosaConstants(getOperation()).failed()) {
+      signalPassFailure();
+    }
+  }
+
+private:
+  using HandleType = size_t;
+
+  HandleType getOpHandle(Operation &op) {
+    return llvm::hash_combine_range(op.result_begin(), op.result_end());
+  }
+
+  bool hasOpInfo(HandleType handle) {
+    return _operations_map.count(handle) != 0;
+  }
+
+  OpInfo &getOpInfo(HandleType handle) {
+    return _operations[_operations_map.at(handle)];
+  }
+
+  void insertOpInfo(HandleType handle, Operation &op, int32_t use_count = 0) {
+    assert(!hasOpInfo(handle));
+    _operations_map.emplace(handle, _operations.size());
+    _operations.emplace_back(OpInfo(op, use_count));
+  }
+
+  HandleType getAttrHandle(Attribute &attr) { return hash_value(attr); }
+
+  bool hasAttrId(HandleType handle) {
+    return _attributes_map.count(handle) != 0;
+  }
+
+  uint32_t getAttrId(HandleType handle) { return _attributes_map.at(handle); }
+
+  void insertAttrId(HandleType handle, uint32_t attr_id) {
+    _attributes_map.emplace(handle, attr_id);
+  }
+
+  uint32_t getOrInsertAttrId(HandleType handle) {
+    if (!hasAttrId(handle)) {
+      insertAttrId(handle, _next_const_id++);
+    }
+    return getAttrId(handle);
+  }
+
+  LogicalResult ConvertTosaConstants(func::FuncOp);
+
+  std::unordered_map<HandleType, uint32_t> _attributes_map;
+  std::unordered_map<HandleType, size_t> _operations_map;
+  std::vector<OpInfo> _operations;
+
+  uint32_t _next_const_id = 0;
+};
+
+LogicalResult
+ConvertTosaConstantsPass::ConvertTosaConstants(func::FuncOp func) {
+  HandleType handle;
+
+  auto &region = func.getRegion();
+  if (!region.hasOneBlock()) {
+    return func.emitError("Invalid MLIR: multiple blocks in a region");
+  }
+
+  auto &block = region.front();
+  if (!block.isEntryBlock()) {
+    return func.emitError("Invalid MLIR: first block is not an entry block");
+  }
+
+  for (auto &op : block) {
+    // Register a tosa.const or tosa.const_shape op in the op map with inital
+    // use count of 0. Use count is incremented when an op uses this const as an
+    // operand.
+    if (llvm::isa<tosa::ConstOp>(op) || llvm::isa<tosa::ConstShapeOp>(op)) {
+      handle = getOpHandle(op);
+      insertOpInfo(handle, op, 0);
+      continue;
+    }
+
+    // For each operation, check if any operand is a tosa.const or
+    // tosa.const_shape and increment use count of its map entry.
+    for (auto &operand : op.getOpOperands()) {
+      if (auto definingOp = operand.get().getDefiningOp()) {
+        // Operand defining op is not tosa.const or tosa.const
+        if (!llvm::isa<tosa::ConstOp>(*definingOp) &&
+            !llvm::isa<tosa::ConstShapeOp>(*definingOp))
+          continue;
+
+        getOpInfo(getOpHandle(*definingOp)).addUseCount();
+      }
+    }
+  }
+
+  for (auto &opInfo : _operations) {
+    if (!opInfo.getUseCount())
+      continue;
+
+    auto &op = opInfo.getOp();
+    if (!isOpGraphConstantARM(&op))
+      continue;
+
+    // Assign graph constant IDs to tosa.const or tosa.const_shape ops having a
+    // non zero use count.
+    setGraphIdForConst(&op, _next_const_id++);
+  }
+
+  return success();
+}
+
+std::unique_ptr<Pass> createConvertTosaConstantsPass() {
+  return std::make_unique<ConvertTosaConstantsPass>();
+}
+
+} // namespace tosa
+} // namespace mlir
diff --git a/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRV.cpp b/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRV.cpp
new file mode 100644
index 000000000000..3b26a077a0df
--- /dev/null
+++ b/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRV.cpp
@@ -0,0 +1,136 @@
+//===- TosaToSPIRV.cpp - Tosa to SPIR-V Patterns --------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements patterns to convert Tosa dialect to SPIRV dialect.
+//
+//===----------------------------------------------------------------------===//
+
+#include "mlir/Conversion/TosaToSPIRV/TosaToSPIRV.h"
+#include "mlir/Dialect/Func/IR/FuncOps.h"
+#include "mlir/Dialect/SPIRV/IR/SPIRVDialect.h"
+#include "mlir/Dialect/SPIRV/IR/SPIRVOps.h"
+#include "mlir/IR/Matchers.h"
+#include "mlir/IR/TypeUtilities.h"
+#include "mlir/Transforms/DialectConversion.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/Support/FormatVariadic.h"
+
+#include "TosaToSPIRVBasePattern.h"
+
+namespace mlir {
+#define GEN_PASS_DEF_CONVERTTOSATOSPIRV
+#include "mlir/Conversion/Passes.h.inc"
+} // namespace mlir
+
+#define DEBUG_TYPE "tosa-to-spirv-pattern"
+using namespace mlir;
+using namespace tosa;
+
+namespace {
+
+struct FuncGraphConvert final : public TosaOpConversionPattern<func::FuncOp> {
+  using TosaOpConversionPattern<func::FuncOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(func::FuncOp funcOp, func::FuncOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    MLIRContext *context = rewriter.getContext();
+
+    StringRef name = adaptor.getSymName();
+
+    bool entryPoint = !isa<func::FuncOp>(funcOp->getParentOp());
+    if (entryPoint) {
+      auto spvModule = spirv::ModuleOp::create(
+          rewriter, funcOp.getLoc(), spirv::AddressingModel::Logical,
+          spirv::MemoryModel::Vulkan, std::nullopt,
+          ("_spirv_tosa_" + name).str());
+
+      rewriter.setInsertionPoint(spvModule.getBody(), spvModule.begin());
+    }
+
+    FunctionType ftype = adaptor.getFunctionType();
+    ArrayAttr argAttrs = adaptor.getArgAttrsAttr();
+    ArrayAttr resAttrs = adaptor.getResAttrsAttr();
+
+    TypeConverter::SignatureConversion signatureConverter(ftype.getNumInputs());
+    if (failed(typeConverter->convertSignatureArgs(ftype.getInputs(),
+                                                   signatureConverter))) {
+      return funcOp.emitError("failed to convert function argument types");
+    }
+
+    // Update the signature of the function.
+    SmallVector<Type, 2> newResultTypes;
+    if (failed(getTypeConverter()->convertTypes(ftype.getResults(),
+                                                newResultTypes))) {
+      return funcOp.emitError("failed to convert function result types");
+    }
+
+    auto graphTy = GraphType::get(
+        context, signatureConverter.getConvertedTypes(), newResultTypes);
+    auto entryPointAttr = BoolAttr::get(context, entryPoint);
+    auto graphOp =
+        spirv::GraphARMOp::create(rewriter, funcOp.getLoc(), graphTy, argAttrs,
+                                  resAttrs, entryPointAttr, name);
+    graphOp->setAttrs(adaptor.getAttributes());
+    rewriter.inlineRegionBefore(funcOp.getBody(), graphOp.getBody(),
+                                graphOp.end());
+    if (failed(rewriter.convertRegionTypes(
+            &graphOp.getBody(), *getTypeConverter(), &signatureConverter))) {
+      return funcOp.emitError("failed to convert function regions");
+    }
+
+    if (entryPoint) {
+      uint32_t descriptorSet = 0;
+      if (auto descriptorSetAttr =
+              funcOp->getAttrOfType<IntegerAttr>("descriptor_set")) {
+        descriptorSet = static_cast<uint32_t>(descriptorSetAttr.getUInt());
+      }
+
+      StringRef varABIAttrName = spirv::getInterfaceVarABIAttrName();
+      unsigned inputs = ftype.getNumInputs();
+      unsigned outputs = ftype.getNumResults();
+      for (auto argIndex : llvm::seq<unsigned>(0, inputs)) {
+        uint32_t binding = argIndex;
+        auto abiInfo = spirv::InterfaceVarABIAttr::get(descriptorSet, binding,
+                                                       std::nullopt, context);
+        graphOp.setArgAttr(argIndex, varABIAttrName, abiInfo);
+      }
+      for (auto resIndex : llvm::seq<unsigned>(0, outputs)) {
+        uint32_t binding = resIndex + inputs;
+        auto abiInfo = spirv::InterfaceVarABIAttr::get(descriptorSet, binding,
+                                                       std::nullopt, context);
+        graphOp.setResultAttr(resIndex, varABIAttrName, abiInfo);
+      }
+    }
+
+    rewriter.eraseOp(funcOp);
+    return success();
+  }
+};
+
+/// Converts func.return to spirv.Return.
+class ReturnGraphOutputConvert final
+    : public TosaOpConversionPattern<func::ReturnOp> {
+  using TosaOpConversionPattern<func::ReturnOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(func::ReturnOp returnOp, OpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    rewriter.replaceOpWithNewOp<spirv::GraphOutputsARMOp>(
+        returnOp, adaptor.getOperands());
+    return success();
+  }
+};
+
+} // namespace
+
+void mlir::tosa::populateTosaToSPIRVConversionPatterns(
+    SPIRVTypeConverter &typeConverter, RewritePatternSet &patterns) {
+  patterns.add<FuncGraphConvert, ReturnGraphOutputConvert>(
+      typeConverter, patterns.getContext());
+}
diff --git a/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRVBasePattern.h b/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRVBasePattern.h
new file mode 100644
index 000000000000..bc237e059a01
--- /dev/null
+++ b/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRVBasePattern.h
@@ -0,0 +1,140 @@
+//===-- TosaToSPIRVBasePattern.h - TOSA to SPIR-V patterns ------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// Provides base pattern to convert Tosa dialect to SPIR-V dialect.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef MLIR_CONVERSION_TOSATOSPIRV_TOSATOSPIRVBASEPATTERN_H
+#define MLIR_CONVERSION_TOSATOSPIRV_TOSATOSPIRVBASEPATTERN_H
+
+#include "mlir/Conversion/TosaToSPIRV/TosaToSPIRV.h"
+#include "mlir/Dialect/Tosa/IR/TosaOps.h"
+#include "mlir/ExecutionEngine/Float16bits.h"
+#include "mlir/IR/TypeUtilities.h"
+#include "mlir/Transforms/DialectConversion.h"
+
+namespace mlir {
+
+namespace tosa {
+
+static constexpr unsigned MAX_CONTACT_OP_INPUTS = 64;
+
+template <typename SourceOp>
+struct TosaOpConversionPattern : public OpConversionPattern<SourceOp> {
+  using OpConversionPattern<SourceOp>::OpConversionPattern;
+
+  TosaOpConversionPattern(SPIRVTypeConverter &typeConverter,
+                          MLIRContext *context)
+      : OpConversionPattern<SourceOp>::OpConversionPattern(typeConverter,
+                                                           context) {}
+
+  Type convertType(Type type) const {
+    return this->getTypeConverter()->convertType(type);
+  }
+
+  Type getConvertedElementType(Value type) const {
+    return this->getTypeConverter()->convertType(getElementTypeOrSelf(type));
+  }
+
+  uint32_t convertAccType(Type accType) const {
+    if (accType.isInteger(32))
+      return 1;
+    if (accType.isF16())
+      return 2;
+    if (accType.isF32())
+      return 3;
+    if (accType.isInteger(48))
+      return 4;
+    llvm_unreachable("Unknown accumulator type");
+  }
+
+  LogicalResult maybeConvertValue(Location loc, ElementsAttr value,
+                                  ElementsAttr &out) const {
+    const ShapedType type = value.getShapedType();
+    const ShapedType convertedType =
+        llvm::dyn_cast_or_null<ShapedType>(convertType(type));
+    if (convertedType == nullptr) {
+      return emitError(
+          loc, "type conversion did not produce the expected shaped type");
+    }
+
+    // if types are the same, nothing to do here
+    if (type == convertedType) {
+      out = value;
+      return success();
+    }
+
+    const auto attr = llvm::dyn_cast_or_null<DenseElementsAttr>(value);
+    if (attr == nullptr) {
+      return emitError(
+          loc, "the attribute is not of the expected dense element attr type");
+    }
+
+    DenseElementsAttr convertedAttr = attr;
+    // if element types are not the same, convert the elements
+    if (getElementTypeOrSelf(type) != getElementTypeOrSelf(convertedType)) {
+      // type conversion is supposed to be done only for integers
+      const IntegerType intType = llvm::dyn_cast_or_null<IntegerType>(
+          getElementTypeOrSelf(convertedType));
+      if (intType == nullptr) {
+        return emitError(
+            loc, "converted element type is expected to be an integet type");
+      }
+
+      // do the conversion
+      if (convertedAttr.empty() && getElementTypeOrSelf(type).isIndex()) {
+        // special case for converting tensor<0xindex> to
+        // !spirv.arm.tensor<1xi32>
+        convertedAttr = DenseIntElementsAttr::get(convertedType, {1});
+      } else {
+        convertedAttr = attr.mapValues(intType, [&](const APInt &value) {
+          return value.sextOrTrunc(intType.getWidth());
+        });
+      }
+    }
+
+    // reshape if needed (for example from rank 0 to rank 1 dim [1])
+    out = convertedAttr.reshape(convertedType);
+    return success();
+  }
+
+  void splitConcat(tosa::ConcatOp op, int64_t axisDimIndex, Value axisValue,
+                   ValueRange inputs, ShapedType inputType,
+                   ConversionPatternRewriter &rewriter) const {
+
+    ArrayRef<int64_t> shape = inputType.getShape();
+    size_t numInputs = inputs.getTypes().size();
+    int64_t axisDim = shape[axisDimIndex];
+
+    SmallVector<int64_t, 6> newShape(shape.begin(), shape.end());
+    newShape[axisDimIndex] = 0;
+    SmallVector<Value, MAX_CONTACT_OP_INPUTS> values;
+    spirv::TosaConcatOp newOp;
+    for (const auto &[index, value] : llvm::enumerate(inputs)) {
+      values.emplace_back(value);
+      newShape[axisDimIndex] += axisDim;
+      if (/* is last? */ index == numInputs - 1) {
+        Type newType = convertType(inputType.clone(newShape));
+        newOp = rewriter.replaceOpWithNewOp<spirv::TosaConcatOp>(
+            op, newType, axisValue, values);
+      } else if (values.size() % MAX_CONTACT_OP_INPUTS == 0) {
+        Type newType = convertType(inputType.clone(newShape));
+        newOp = spirv::TosaConcatOp::create(rewriter, op->getLoc(), newType,
+                                            axisValue, values);
+        values.clear();
+        values.emplace_back(newOp.getOutput());
+      }
+    }
+  }
+};
+
+} // namespace tosa
+} // namespace mlir
+
+#endif // MLIR_CONVERSION_TOSATOSPIRV_TOSATOSPIRVBASEPATTERN_H
diff --git a/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRVOps.cpp b/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRVOps.cpp
new file mode 100644
index 000000000000..d44b44a691f4
--- /dev/null
+++ b/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRVOps.cpp
@@ -0,0 +1,1430 @@
+//===- TosaToSPIRVOps.cpp - Tosa to SPIR-V Patterns -----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements patterns to convert Tosa dialect to SPIRV dialect.
+//
+//===----------------------------------------------------------------------===//
+
+#include "mlir/Conversion/TosaToSPIRV/ConvertTosaConstants.h"
+#include "mlir/Conversion/TosaToSPIRV/TosaToSPIRV.h"
+#include "mlir/Dialect/SPIRV/IR/SPIRVDialect.h"
+#include "mlir/Dialect/SPIRV/IR/SPIRVOps.h"
+#include "mlir/Dialect/SPIRV/IR/SPIRVTypes.h"
+#include "mlir/Dialect/Tosa/IR/TosaOps.h"
+#include "mlir/IR/Matchers.h"
+#include "mlir/Transforms/DialectConversion.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/Support/FormatVariadic.h"
+
+#include "TosaToSPIRVBasePattern.h"
+
+namespace mlir {
+#define GEN_PASS_DEF_CONVERTTOSATOSPIRV
+#include "mlir/Conversion/Passes.h.inc"
+} // namespace mlir
+
+#define DEBUG_TYPE "tosa-to-spirv-ops-pattern"
+using namespace mlir;
+using namespace tosa;
+
+namespace {
+
+DenseIntElementsAttr getI32TensorArmAttr(ArrayRef<int32_t> values,
+                                         ConversionPatternRewriter &rewriter) {
+  return DenseIntElementsAttr::get(
+      spirv::TensorArmType::get(static_cast<int64_t>(values.size()),
+                                IntegerType::get(rewriter.getContext(), 32)),
+      values);
+}
+
+struct TosaArgMaxConvert final
+    : public TosaOpConversionPattern<tosa::ArgMaxOp> {
+  using TosaOpConversionPattern<tosa::ArgMaxOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ArgMaxOp op, tosa::ArgMaxOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Value axis = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI32, adaptor.getAxisAttr());
+    auto nanModeAttr = rewriter.getIntegerAttr(
+        tI32, static_cast<int32_t>(adaptor.getNanMode()));
+    Value nanMode = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             nanModeAttr);
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaArgMaxOp>(
+        op, convertType(op.getType()), axis, nanMode, input);
+    return success();
+  }
+};
+
+struct TosaAvgPool2DConvert final
+    : public TosaOpConversionPattern<tosa::AvgPool2dOp> {
+  using TosaOpConversionPattern<tosa::AvgPool2dOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::AvgPool2dOp op, tosa::AvgPool2dOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Type tKernel = spirv::TensorArmType::get({2}, tI32);
+    Type tStride = spirv::TensorArmType::get({2}, tI32);
+    Type tPad = spirv::TensorArmType::get({4}, tI32);
+    auto kernelTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getKernel()), rewriter);
+    Value kernel = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tKernel, kernelTensorAttr);
+    auto strideTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getStride()), rewriter);
+    Value stride = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tStride, strideTensorAttr);
+    auto padTensorAttr =
+        getI32TensorArmAttr(SmallVector<int32_t>(adaptor.getPad()), rewriter);
+    Value pad = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tPad,
+                                                         padTensorAttr);
+    auto accTypeAttr =
+        rewriter.getIntegerAttr(tI32, convertAccType(adaptor.getAccType()));
+    Value accType = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             accTypeAttr);
+    Value input = adaptor.getInput();
+    Value inputZp = adaptor.getInputZp();
+    Value outputZp = adaptor.getOutputZp();
+    rewriter.replaceOpWithNewOp<spirv::TosaAvgPool2DOp>(
+        op, convertType(op.getType()), kernel, stride, pad, accType, input,
+        inputZp, outputZp);
+    return success();
+  }
+};
+
+struct TosaConv2DConvert final
+    : public TosaOpConversionPattern<tosa::Conv2DOp> {
+  using TosaOpConversionPattern<tosa::Conv2DOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::Conv2DOp op, tosa::Conv2DOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Type tPad = spirv::TensorArmType::get({4}, tI32);
+    Type tStride = spirv::TensorArmType::get({2}, tI32);
+    Type tDilation = spirv::TensorArmType::get({2}, tI32);
+    Type tI1 = rewriter.getIntegerType(1);
+    auto padTensorAttr =
+        getI32TensorArmAttr(SmallVector<int32_t>(adaptor.getPad()), rewriter);
+    Value pad = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tPad,
+                                                         padTensorAttr);
+    auto strideTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getStride()), rewriter);
+    Value stride = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tStride, strideTensorAttr);
+    auto dilationTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getDilation()), rewriter);
+    Value dilation = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tDilation, dilationTensorAttr);
+    auto accTypeAttr =
+        rewriter.getIntegerAttr(tI32, convertAccType(adaptor.getAccType()));
+    Value accType = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             accTypeAttr);
+    Value localBound = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getLocalBoundAttr());
+    Value input = adaptor.getInput();
+    Value weight = adaptor.getWeight();
+    Value bias = adaptor.getBias();
+    Value inputZp = adaptor.getInputZp();
+    Value weightZp = adaptor.getWeightZp();
+    rewriter.replaceOpWithNewOp<spirv::TosaConv2DOp>(
+        op, convertType(op.getType()), pad, stride, dilation, accType,
+        localBound, input, weight, bias, inputZp, weightZp);
+    return success();
+  }
+};
+
+struct TosaConv3DConvert final
+    : public TosaOpConversionPattern<tosa::Conv3DOp> {
+  using TosaOpConversionPattern<tosa::Conv3DOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::Conv3DOp op, tosa::Conv3DOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Type tPad = spirv::TensorArmType::get({6}, tI32);
+    Type tStride = spirv::TensorArmType::get({3}, tI32);
+    Type tDilation = spirv::TensorArmType::get({3}, tI32);
+    Type tI1 = rewriter.getIntegerType(1);
+    auto padTensorAttr =
+        getI32TensorArmAttr(SmallVector<int32_t>(adaptor.getPad()), rewriter);
+    Value pad = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tPad,
+                                                         padTensorAttr);
+    auto strideTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getStride()), rewriter);
+    Value stride = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tStride, strideTensorAttr);
+    auto dilationTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getDilation()), rewriter);
+    Value dilation = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tDilation, dilationTensorAttr);
+    auto accTypeAttr =
+        rewriter.getIntegerAttr(tI32, convertAccType(adaptor.getAccType()));
+    Value accType = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             accTypeAttr);
+    Value localBound = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getLocalBoundAttr());
+    Value input = adaptor.getInput();
+    Value weight = adaptor.getWeight();
+    Value bias = adaptor.getBias();
+    Value inputZp = adaptor.getInputZp();
+    Value weightZp = adaptor.getWeightZp();
+    rewriter.replaceOpWithNewOp<spirv::TosaConv3DOp>(
+        op, convertType(op.getType()), pad, stride, dilation, accType,
+        localBound, input, weight, bias, inputZp, weightZp);
+    return success();
+  }
+};
+
+struct TosaDepthwiseConv2DConvert final
+    : public TosaOpConversionPattern<tosa::DepthwiseConv2DOp> {
+  using TosaOpConversionPattern<
+      tosa::DepthwiseConv2DOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::DepthwiseConv2DOp op,
+                  tosa::DepthwiseConv2DOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Type tPad = spirv::TensorArmType::get({4}, tI32);
+    Type tStride = spirv::TensorArmType::get({2}, tI32);
+    Type tDilation = spirv::TensorArmType::get({2}, tI32);
+    Type tI1 = rewriter.getIntegerType(1);
+    auto padTensorAttr =
+        getI32TensorArmAttr(SmallVector<int32_t>(adaptor.getPad()), rewriter);
+    Value pad = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tPad,
+                                                         padTensorAttr);
+    auto strideTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getStride()), rewriter);
+    Value stride = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tStride, strideTensorAttr);
+    auto dilationTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getDilation()), rewriter);
+    Value dilation = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tDilation, dilationTensorAttr);
+    auto accTypeAttr =
+        rewriter.getIntegerAttr(tI32, convertAccType(adaptor.getAccType()));
+    Value accType = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             accTypeAttr);
+    Value localBound = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getLocalBoundAttr());
+    Value input = adaptor.getInput();
+    Value weight = adaptor.getWeight();
+    Value bias = adaptor.getBias();
+    Value inputZp = adaptor.getInputZp();
+    Value weightZp = adaptor.getWeightZp();
+    rewriter.replaceOpWithNewOp<spirv::TosaDepthwiseConv2DOp>(
+        op, convertType(op.getType()), pad, stride, dilation, accType,
+        localBound, input, weight, bias, inputZp, weightZp);
+    return success();
+  }
+};
+
+struct TosaFFT2DConvert final : public TosaOpConversionPattern<tosa::FFT2dOp> {
+  using TosaOpConversionPattern<tosa::FFT2dOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::FFT2dOp op, tosa::FFT2dOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI1 = rewriter.getIntegerType(1);
+    Value inverse = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getInverseAttr());
+    Value localBound = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getLocalBoundAttr());
+    Value inputReal = adaptor.getInputReal();
+    Value inputImag = adaptor.getInputImag();
+    spirv::StructType structType = spirv::StructType::get(
+        {convertType(op.getType(0)), convertType(op.getType(1))});
+
+    Value result =
+        spirv::TosaFFT2DOp::create(rewriter, op->getLoc(), structType, inverse,
+                                   localBound, inputReal, inputImag);
+
+    Value outputReal = spirv::CompositeExtractOp::create(
+        rewriter, op->getLoc(), result, llvm::ArrayRef(0));
+    Value outputImag = spirv::CompositeExtractOp::create(
+        rewriter, op->getLoc(), result, llvm::ArrayRef(1));
+
+    rewriter.replaceOp(op, {outputReal, outputImag});
+
+    return success();
+  }
+};
+
+struct TosaMatMulConvert final
+    : public TosaOpConversionPattern<tosa::MatMulOp> {
+  using TosaOpConversionPattern<tosa::MatMulOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::MatMulOp op, tosa::MatMulOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value A = adaptor.getA();
+    Value B = adaptor.getB();
+    Value AZp = adaptor.getAZp();
+    Value BZp = adaptor.getBZp();
+    rewriter.replaceOpWithNewOp<spirv::TosaMatMulOp>(
+        op, convertType(op.getType()), A, B, AZp, BZp);
+    return success();
+  }
+};
+
+struct TosaMaxPool2DConvert final
+    : public TosaOpConversionPattern<tosa::MaxPool2dOp> {
+  using TosaOpConversionPattern<tosa::MaxPool2dOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::MaxPool2dOp op, tosa::MaxPool2dOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Type tKernel = spirv::TensorArmType::get({2}, tI32);
+    Type tStride = spirv::TensorArmType::get({2}, tI32);
+    Type tPad = spirv::TensorArmType::get({4}, tI32);
+    auto kernelTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getKernel()), rewriter);
+    Value kernel = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tKernel, kernelTensorAttr);
+    auto strideTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getStride()), rewriter);
+    Value stride = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tStride, strideTensorAttr);
+    auto padTensorAttr =
+        getI32TensorArmAttr(SmallVector<int32_t>(adaptor.getPad()), rewriter);
+    Value pad = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tPad,
+                                                         padTensorAttr);
+    auto nanModeAttr = rewriter.getIntegerAttr(
+        tI32, static_cast<int32_t>(adaptor.getNanMode()));
+    Value nanMode = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             nanModeAttr);
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaMaxPool2DOp>(
+        op, convertType(op.getType()), kernel, stride, pad, nanMode, input);
+    return success();
+  }
+};
+
+struct TosaRFFT2DConvert final
+    : public TosaOpConversionPattern<tosa::RFFT2dOp> {
+  using TosaOpConversionPattern<tosa::RFFT2dOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::RFFT2dOp op, tosa::RFFT2dOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI1 = rewriter.getIntegerType(1);
+    Value localBound = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getLocalBoundAttr());
+    Value inputReal = adaptor.getInputReal();
+    spirv::StructType structType = spirv::StructType::get(
+        {convertType(op.getType(0)), convertType(op.getType(1))});
+
+    Value result = spirv::TosaRFFT2DOp::create(
+        rewriter, op->getLoc(), structType, localBound, inputReal);
+
+    Value outputReal = spirv::CompositeExtractOp::create(
+        rewriter, op->getLoc(), result, llvm::ArrayRef(0));
+    Value outputImag = spirv::CompositeExtractOp::create(
+        rewriter, op->getLoc(), result, llvm::ArrayRef(1));
+
+    rewriter.replaceOp(op, {outputReal, outputImag});
+
+    return success();
+  }
+};
+
+struct TosaTransposeConv2DConvert final
+    : public TosaOpConversionPattern<tosa::TransposeConv2DOp> {
+  using TosaOpConversionPattern<
+      tosa::TransposeConv2DOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::TransposeConv2DOp op,
+                  tosa::TransposeConv2DOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Type tOutPad = spirv::TensorArmType::get({4}, tI32);
+    Type tStride = spirv::TensorArmType::get({2}, tI32);
+    Type tI1 = rewriter.getIntegerType(1);
+    auto outPadTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getOutPad()), rewriter);
+    Value outPad = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tOutPad, outPadTensorAttr);
+    auto strideTensorAttr = getI32TensorArmAttr(
+        SmallVector<int32_t>(adaptor.getStride()), rewriter);
+    Value stride = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tStride, strideTensorAttr);
+    auto accTypeAttr =
+        rewriter.getIntegerAttr(tI32, convertAccType(adaptor.getAccType()));
+    Value accType = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             accTypeAttr);
+    Value localBound = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getLocalBoundAttr());
+    Value input = adaptor.getInput();
+    Value weight = adaptor.getWeight();
+    Value bias = adaptor.getBias();
+    Value inputZp = adaptor.getInputZp();
+    Value weightZp = adaptor.getWeightZp();
+    rewriter.replaceOpWithNewOp<spirv::TosaTransposeConv2DOp>(
+        op, convertType(op.getType()), outPad, stride, accType, localBound,
+        input, weight, bias, inputZp, weightZp);
+    return success();
+  }
+};
+
+struct TosaClampConvert final : public TosaOpConversionPattern<tosa::ClampOp> {
+  using TosaOpConversionPattern<tosa::ClampOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ClampOp op, tosa::ClampOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tOutput = getConvertedElementType(op.getOutput());
+    Type tI32 = rewriter.getIntegerType(32);
+    Value minVal = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tOutput, adaptor.getMinValAttr());
+    Value maxVal = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tOutput, adaptor.getMaxValAttr());
+    auto nanModeAttr = rewriter.getIntegerAttr(
+        tI32, static_cast<int32_t>(adaptor.getNanMode()));
+    Value nanMode = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             nanModeAttr);
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaClampOp>(
+        op, convertType(op.getType()), minVal, maxVal, nanMode, input);
+    return success();
+  }
+};
+
+struct TosaErfConvert final : public TosaOpConversionPattern<tosa::ErfOp> {
+  using TosaOpConversionPattern<tosa::ErfOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ErfOp op, tosa::ErfOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaErfOp>(op, convertType(op.getType()),
+                                                  input);
+    return success();
+  }
+};
+
+struct TosaSigmoidConvert final
+    : public TosaOpConversionPattern<tosa::SigmoidOp> {
+  using TosaOpConversionPattern<tosa::SigmoidOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::SigmoidOp op, tosa::SigmoidOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaSigmoidOp>(
+        op, convertType(op.getType()), input);
+    return success();
+  }
+};
+
+struct TosaTanhConvert final : public TosaOpConversionPattern<tosa::TanhOp> {
+  using TosaOpConversionPattern<tosa::TanhOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::TanhOp op, tosa::TanhOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaTanhOp>(
+        op, convertType(op.getType()), input);
+    return success();
+  }
+};
+
+struct TosaAddConvert final : public TosaOpConversionPattern<tosa::AddOp> {
+  using TosaOpConversionPattern<tosa::AddOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::AddOp op, tosa::AddOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaAddOp>(op, convertType(op.getType()),
+                                                  input1, input2);
+    return success();
+  }
+};
+
+struct TosaArithmeticRightShiftConvert final
+    : public TosaOpConversionPattern<tosa::ArithmeticRightShiftOp> {
+  using TosaOpConversionPattern<
+      tosa::ArithmeticRightShiftOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ArithmeticRightShiftOp op,
+                  tosa::ArithmeticRightShiftOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI1 = rewriter.getIntegerType(1);
+    Value round = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getRoundAttr());
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaArithmeticRightShiftOp>(
+        op, convertType(op.getType()), round, input1, input2);
+    return success();
+  }
+};
+
+struct TosaBitwiseAndConvert final
+    : public TosaOpConversionPattern<tosa::BitwiseAndOp> {
+  using TosaOpConversionPattern<tosa::BitwiseAndOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::BitwiseAndOp op, tosa::BitwiseAndOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaBitwiseAndOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaBitwiseOrConvert final
+    : public TosaOpConversionPattern<tosa::BitwiseOrOp> {
+  using TosaOpConversionPattern<tosa::BitwiseOrOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::BitwiseOrOp op, tosa::BitwiseOrOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaBitwiseOrOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaBitwiseXorConvert final
+    : public TosaOpConversionPattern<tosa::BitwiseXorOp> {
+  using TosaOpConversionPattern<tosa::BitwiseXorOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::BitwiseXorOp op, tosa::BitwiseXorOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaBitwiseXorOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaIntDivConvert final
+    : public TosaOpConversionPattern<tosa::IntDivOp> {
+  using TosaOpConversionPattern<tosa::IntDivOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::IntDivOp op, tosa::IntDivOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaIntDivOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaLogicalAndConvert final
+    : public TosaOpConversionPattern<tosa::LogicalAndOp> {
+  using TosaOpConversionPattern<tosa::LogicalAndOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::LogicalAndOp op, tosa::LogicalAndOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaLogicalAndOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaLogicalLeftShiftConvert final
+    : public TosaOpConversionPattern<tosa::LogicalLeftShiftOp> {
+  using TosaOpConversionPattern<
+      tosa::LogicalLeftShiftOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::LogicalLeftShiftOp op,
+                  tosa::LogicalLeftShiftOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaLogicalLeftShiftOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaLogicalRightShiftConvert final
+    : public TosaOpConversionPattern<tosa::LogicalRightShiftOp> {
+  using TosaOpConversionPattern<
+      tosa::LogicalRightShiftOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::LogicalRightShiftOp op,
+                  tosa::LogicalRightShiftOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaLogicalRightShiftOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaLogicalOrConvert final
+    : public TosaOpConversionPattern<tosa::LogicalOrOp> {
+  using TosaOpConversionPattern<tosa::LogicalOrOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::LogicalOrOp op, tosa::LogicalOrOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaLogicalOrOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaLogicalXorConvert final
+    : public TosaOpConversionPattern<tosa::LogicalXorOp> {
+  using TosaOpConversionPattern<tosa::LogicalXorOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::LogicalXorOp op, tosa::LogicalXorOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaLogicalXorOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaMaximumConvert final
+    : public TosaOpConversionPattern<tosa::MaximumOp> {
+  using TosaOpConversionPattern<tosa::MaximumOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::MaximumOp op, tosa::MaximumOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    auto nanModeAttr = rewriter.getIntegerAttr(
+        tI32, static_cast<int32_t>(adaptor.getNanMode()));
+    Value nanMode = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             nanModeAttr);
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaMaximumOp>(
+        op, convertType(op.getType()), nanMode, input1, input2);
+    return success();
+  }
+};
+
+struct TosaMinimumConvert final
+    : public TosaOpConversionPattern<tosa::MinimumOp> {
+  using TosaOpConversionPattern<tosa::MinimumOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::MinimumOp op, tosa::MinimumOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    auto nanModeAttr = rewriter.getIntegerAttr(
+        tI32, static_cast<int32_t>(adaptor.getNanMode()));
+    Value nanMode = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             nanModeAttr);
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaMinimumOp>(
+        op, convertType(op.getType()), nanMode, input1, input2);
+    return success();
+  }
+};
+
+struct TosaMulConvert final : public TosaOpConversionPattern<tosa::MulOp> {
+  using TosaOpConversionPattern<tosa::MulOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::MulOp op, tosa::MulOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    Value shift = adaptor.getShift();
+    rewriter.replaceOpWithNewOp<spirv::TosaMulOp>(op, convertType(op.getType()),
+                                                  input1, input2, shift);
+    return success();
+  }
+};
+
+struct TosaPowConvert final : public TosaOpConversionPattern<tosa::PowOp> {
+  using TosaOpConversionPattern<tosa::PowOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::PowOp op, tosa::PowOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaPowOp>(op, convertType(op.getType()),
+                                                  input1, input2);
+    return success();
+  }
+};
+
+struct TosaSubConvert final : public TosaOpConversionPattern<tosa::SubOp> {
+  using TosaOpConversionPattern<tosa::SubOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::SubOp op, tosa::SubOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaSubOp>(op, convertType(op.getType()),
+                                                  input1, input2);
+    return success();
+  }
+};
+
+struct TosaTableConvert final : public TosaOpConversionPattern<tosa::TableOp> {
+  using TosaOpConversionPattern<tosa::TableOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::TableOp op, tosa::TableOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value table = adaptor.getTable();
+    rewriter.replaceOpWithNewOp<spirv::TosaTableOp>(
+        op, convertType(op.getType()), input1, table);
+    return success();
+  }
+};
+
+struct TosaAbsConvert final : public TosaOpConversionPattern<tosa::AbsOp> {
+  using TosaOpConversionPattern<tosa::AbsOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::AbsOp op, tosa::AbsOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaAbsOp>(op, convertType(op.getType()),
+                                                  input1);
+    return success();
+  }
+};
+
+struct TosaBitwiseNotConvert final
+    : public TosaOpConversionPattern<tosa::BitwiseNotOp> {
+  using TosaOpConversionPattern<tosa::BitwiseNotOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::BitwiseNotOp op, tosa::BitwiseNotOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaBitwiseNotOp>(
+        op, convertType(op.getType()), input1);
+    return success();
+  }
+};
+
+struct TosaCeilConvert final : public TosaOpConversionPattern<tosa::CeilOp> {
+  using TosaOpConversionPattern<tosa::CeilOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::CeilOp op, tosa::CeilOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaCeilOp>(
+        op, convertType(op.getType()), input1);
+    return success();
+  }
+};
+
+struct TosaClzConvert final : public TosaOpConversionPattern<tosa::ClzOp> {
+  using TosaOpConversionPattern<tosa::ClzOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ClzOp op, tosa::ClzOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaClzOp>(op, convertType(op.getType()),
+                                                  input1);
+    return success();
+  }
+};
+
+struct TosaCosConvert final : public TosaOpConversionPattern<tosa::CosOp> {
+  using TosaOpConversionPattern<tosa::CosOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::CosOp op, tosa::CosOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaCosOp>(op, convertType(op.getType()),
+                                                  input1);
+    return success();
+  }
+};
+
+struct TosaExpConvert final : public TosaOpConversionPattern<tosa::ExpOp> {
+  using TosaOpConversionPattern<tosa::ExpOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ExpOp op, tosa::ExpOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaExpOp>(op, convertType(op.getType()),
+                                                  input1);
+    return success();
+  }
+};
+
+struct TosaFloorConvert final : public TosaOpConversionPattern<tosa::FloorOp> {
+  using TosaOpConversionPattern<tosa::FloorOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::FloorOp op, tosa::FloorOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaFloorOp>(
+        op, convertType(op.getType()), input1);
+    return success();
+  }
+};
+
+struct TosaLogConvert final : public TosaOpConversionPattern<tosa::LogOp> {
+  using TosaOpConversionPattern<tosa::LogOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::LogOp op, tosa::LogOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaLogOp>(op, convertType(op.getType()),
+                                                  input1);
+    return success();
+  }
+};
+
+struct TosaLogicalNotConvert final
+    : public TosaOpConversionPattern<tosa::LogicalNotOp> {
+  using TosaOpConversionPattern<tosa::LogicalNotOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::LogicalNotOp op, tosa::LogicalNotOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaLogicalNotOp>(
+        op, convertType(op.getType()), input1);
+    return success();
+  }
+};
+
+struct TosaNegateConvert final
+    : public TosaOpConversionPattern<tosa::NegateOp> {
+  using TosaOpConversionPattern<tosa::NegateOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::NegateOp op, tosa::NegateOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input1Zp = adaptor.getInput1Zp();
+    Value outputZp = adaptor.getOutputZp();
+    rewriter.replaceOpWithNewOp<spirv::TosaNegateOp>(
+        op, convertType(op.getType()), input1, input1Zp, outputZp);
+    return success();
+  }
+};
+
+struct TosaReciprocalConvert final
+    : public TosaOpConversionPattern<tosa::ReciprocalOp> {
+  using TosaOpConversionPattern<tosa::ReciprocalOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ReciprocalOp op, tosa::ReciprocalOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaReciprocalOp>(
+        op, convertType(op.getType()), input1);
+    return success();
+  }
+};
+
+struct TosaRsqrtConvert final : public TosaOpConversionPattern<tosa::RsqrtOp> {
+  using TosaOpConversionPattern<tosa::RsqrtOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::RsqrtOp op, tosa::RsqrtOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaRsqrtOp>(
+        op, convertType(op.getType()), input1);
+    return success();
+  }
+};
+
+struct TosaSinConvert final : public TosaOpConversionPattern<tosa::SinOp> {
+  using TosaOpConversionPattern<tosa::SinOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::SinOp op, tosa::SinOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaSinOp>(op, convertType(op.getType()),
+                                                  input1);
+    return success();
+  }
+};
+
+struct TosaSelectConvert final
+    : public TosaOpConversionPattern<tosa::SelectOp> {
+  using TosaOpConversionPattern<tosa::SelectOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::SelectOp op, tosa::SelectOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    Value input3 = adaptor.getInput3();
+    rewriter.replaceOpWithNewOp<spirv::TosaSelectOp>(
+        op, convertType(op.getType()), input1, input2, input3);
+    return success();
+  }
+};
+
+struct TosaEqualConvert final : public TosaOpConversionPattern<tosa::EqualOp> {
+  using TosaOpConversionPattern<tosa::EqualOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::EqualOp op, tosa::EqualOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaEqualOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaGreaterConvert final
+    : public TosaOpConversionPattern<tosa::GreaterOp> {
+  using TosaOpConversionPattern<tosa::GreaterOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::GreaterOp op, tosa::GreaterOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaGreaterOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaGreaterEqualConvert final
+    : public TosaOpConversionPattern<tosa::GreaterEqualOp> {
+  using TosaOpConversionPattern<tosa::GreaterEqualOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::GreaterEqualOp op, tosa::GreaterEqualOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value input2 = adaptor.getInput2();
+    rewriter.replaceOpWithNewOp<spirv::TosaGreaterEqualOp>(
+        op, convertType(op.getType()), input1, input2);
+    return success();
+  }
+};
+
+struct TosaReduceAllConvert final
+    : public TosaOpConversionPattern<tosa::ReduceAllOp> {
+  using TosaOpConversionPattern<tosa::ReduceAllOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ReduceAllOp op, tosa::ReduceAllOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Value axis = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI32, adaptor.getAxisAttr());
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaReduceAllOp>(
+        op, convertType(op.getType()), axis, input);
+    return success();
+  }
+};
+
+struct TosaReduceAnyConvert final
+    : public TosaOpConversionPattern<tosa::ReduceAnyOp> {
+  using TosaOpConversionPattern<tosa::ReduceAnyOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ReduceAnyOp op, tosa::ReduceAnyOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Value axis = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI32, adaptor.getAxisAttr());
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaReduceAnyOp>(
+        op, convertType(op.getType()), axis, input);
+    return success();
+  }
+};
+
+struct TosaReduceMaxConvert final
+    : public TosaOpConversionPattern<tosa::ReduceMaxOp> {
+  using TosaOpConversionPattern<tosa::ReduceMaxOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ReduceMaxOp op, tosa::ReduceMaxOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Value axis = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI32, adaptor.getAxisAttr());
+    auto nanModeAttr = rewriter.getIntegerAttr(
+        tI32, static_cast<int32_t>(adaptor.getNanMode()));
+    Value nanMode = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             nanModeAttr);
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaReduceMaxOp>(
+        op, convertType(op.getType()), axis, nanMode, input);
+    return success();
+  }
+};
+
+struct TosaReduceMinConvert final
+    : public TosaOpConversionPattern<tosa::ReduceMinOp> {
+  using TosaOpConversionPattern<tosa::ReduceMinOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ReduceMinOp op, tosa::ReduceMinOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Value axis = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI32, adaptor.getAxisAttr());
+    auto nanModeAttr = rewriter.getIntegerAttr(
+        tI32, static_cast<int32_t>(adaptor.getNanMode()));
+    Value nanMode = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32,
+                                                             nanModeAttr);
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaReduceMinOp>(
+        op, convertType(op.getType()), axis, nanMode, input);
+    return success();
+  }
+};
+
+struct TosaReduceProductConvert final
+    : public TosaOpConversionPattern<tosa::ReduceProductOp> {
+  using TosaOpConversionPattern<tosa::ReduceProductOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ReduceProductOp op,
+                  tosa::ReduceProductOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Value axis = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI32, adaptor.getAxisAttr());
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaReduceProductOp>(
+        op, convertType(op.getType()), axis, input);
+    return success();
+  }
+};
+
+struct TosaReduceSumConvert final
+    : public TosaOpConversionPattern<tosa::ReduceSumOp> {
+  using TosaOpConversionPattern<tosa::ReduceSumOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ReduceSumOp op, tosa::ReduceSumOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Value axis = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI32, adaptor.getAxisAttr());
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaReduceSumOp>(
+        op, convertType(op.getType()), axis, input);
+    return success();
+  }
+};
+
+struct TosaConcatConvert final
+    : public TosaOpConversionPattern<tosa::ConcatOp> {
+  using TosaOpConversionPattern<tosa::ConcatOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ConcatOp op, tosa::ConcatOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Value axis = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI32, adaptor.getAxisAttr());
+    ValueRange input1 = adaptor.getInput1();
+    if (input1.getTypes().size() > MAX_CONTACT_OP_INPUTS) {
+      // The type is the same for all concat inputs so extract the first
+      ShapedType inputType = dyn_cast<ShapedType>(input1.getTypes().front());
+      if (!inputType) {
+        return emitError(op->getLoc(),
+                         "input types of Concat must be shaped types");
+      }
+      splitConcat(op, adaptor.getAxis(), axis, input1, inputType, rewriter);
+    } else {
+      rewriter.replaceOpWithNewOp<spirv::TosaConcatOp>(
+          op, convertType(op.getType()), axis, input1);
+    }
+    return success();
+  }
+};
+
+struct TosaPadConvert final : public TosaOpConversionPattern<tosa::PadOp> {
+  using TosaOpConversionPattern<tosa::PadOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::PadOp op, tosa::PadOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value padding = adaptor.getPadding();
+    Value padConst = adaptor.getPadConst();
+    rewriter.replaceOpWithNewOp<spirv::TosaPadOp>(op, convertType(op.getType()),
+                                                  input1, padding, padConst);
+    return success();
+  }
+};
+
+struct TosaReshapeConvert final
+    : public TosaOpConversionPattern<tosa::ReshapeOp> {
+  using TosaOpConversionPattern<tosa::ReshapeOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ReshapeOp op, tosa::ReshapeOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value shape = adaptor.getShape();
+    rewriter.replaceOpWithNewOp<spirv::TosaReshapeOp>(
+        op, convertType(op.getType()), input1, shape);
+    return success();
+  }
+};
+
+struct TosaReverseConvert final
+    : public TosaOpConversionPattern<tosa::ReverseOp> {
+  using TosaOpConversionPattern<tosa::ReverseOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ReverseOp op, tosa::ReverseOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Value axis = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI32, adaptor.getAxisAttr());
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaReverseOp>(
+        op, convertType(op.getType()), axis, input1);
+    return success();
+  }
+};
+
+struct TosaSliceConvert final : public TosaOpConversionPattern<tosa::SliceOp> {
+  using TosaOpConversionPattern<tosa::SliceOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::SliceOp op, tosa::SliceOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value start = adaptor.getStart();
+    Value size = adaptor.getSize();
+    rewriter.replaceOpWithNewOp<spirv::TosaSliceOp>(
+        op, convertType(op.getType()), input1, start, size);
+    return success();
+  }
+};
+
+struct TosaTileConvert final : public TosaOpConversionPattern<tosa::TileOp> {
+  using TosaOpConversionPattern<tosa::TileOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::TileOp op, tosa::TileOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input1 = adaptor.getInput1();
+    Value multiples = adaptor.getMultiples();
+    rewriter.replaceOpWithNewOp<spirv::TosaTileOp>(
+        op, convertType(op.getType()), input1, multiples);
+    return success();
+  }
+};
+
+struct TosaTransposeConvert final
+    : public TosaOpConversionPattern<tosa::TransposeOp> {
+  using TosaOpConversionPattern<tosa::TransposeOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::TransposeOp op, tosa::TransposeOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    Type tPerms = spirv::TensorArmType::get(
+        {cast<spirv::TensorArmType>(adaptor.getInput1().getType()).getRank()},
+        tI32);
+    auto permsTensorAttr =
+        getI32TensorArmAttr(SmallVector<int32_t>(adaptor.getPerms()), rewriter);
+    Value perms = rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tPerms,
+                                                           permsTensorAttr);
+    Value input1 = adaptor.getInput1();
+    rewriter.replaceOpWithNewOp<spirv::TosaTransposeOp>(
+        op, convertType(op.getType()), perms, input1);
+    return success();
+  }
+};
+
+struct TosaGatherConvert final
+    : public TosaOpConversionPattern<tosa::GatherOp> {
+  using TosaOpConversionPattern<tosa::GatherOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::GatherOp op, tosa::GatherOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value values = adaptor.getValues();
+    Value indices = adaptor.getIndices();
+    rewriter.replaceOpWithNewOp<spirv::TosaGatherOp>(
+        op, convertType(op.getType()), values, indices);
+    return success();
+  }
+};
+
+struct TosaScatterConvert final
+    : public TosaOpConversionPattern<tosa::ScatterOp> {
+  using TosaOpConversionPattern<tosa::ScatterOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ScatterOp op, tosa::ScatterOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value valuesIn = adaptor.getValuesIn();
+    Value indices = adaptor.getIndices();
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaScatterOp>(
+        op, convertType(op.getType()), valuesIn, indices, input);
+    return success();
+  }
+};
+
+struct TosaResizeConvert final
+    : public TosaOpConversionPattern<tosa::ResizeOp> {
+  using TosaOpConversionPattern<tosa::ResizeOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ResizeOp op, tosa::ResizeOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI32 = rewriter.getIntegerType(32);
+    auto modeAttr =
+        rewriter.getIntegerAttr(tI32, static_cast<int32_t>(adaptor.getMode()));
+    Value mode =
+        rewriter.createOrFold<spirv::ConstantOp>(op.getLoc(), tI32, modeAttr);
+    Value input = adaptor.getInput();
+    Value scale = adaptor.getScale();
+    Value offset = adaptor.getOffset();
+    Value border = adaptor.getBorder();
+    rewriter.replaceOpWithNewOp<spirv::TosaResizeOp>(
+        op, convertType(op.getType()), mode, input, scale, offset, border);
+    return success();
+  }
+};
+
+struct TosaCastConvert final : public TosaOpConversionPattern<tosa::CastOp> {
+  using TosaOpConversionPattern<tosa::CastOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::CastOp op, tosa::CastOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    Value input = adaptor.getInput();
+    rewriter.replaceOpWithNewOp<spirv::TosaCastOp>(
+        op, convertType(op.getType()), input);
+    return success();
+  }
+};
+
+struct TosaRescaleConvert final
+    : public TosaOpConversionPattern<tosa::RescaleOp> {
+  using TosaOpConversionPattern<tosa::RescaleOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::RescaleOp op, tosa::RescaleOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    Type tI1 = rewriter.getIntegerType(1);
+    Type tI32 = rewriter.getIntegerType(32);
+    Value scale32 = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getScale32Attr());
+    auto roundingModeAttr = rewriter.getIntegerAttr(
+        tI32, static_cast<int32_t>(adaptor.getRoundingMode()));
+    Value roundingMode = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI32, roundingModeAttr);
+    Value perChannel = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getPerChannelAttr());
+    Value inputUnsigned = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getInputUnsignedAttr());
+    Value outputUnsigned = rewriter.createOrFold<spirv::ConstantOp>(
+        op.getLoc(), tI1, adaptor.getOutputUnsignedAttr());
+    Value input = adaptor.getInput();
+    Value multiplier = adaptor.getMultiplier();
+    Value shift = adaptor.getShift();
+    Value inputZp = adaptor.getInputZp();
+    Value outputZp = adaptor.getOutputZp();
+    rewriter.replaceOpWithNewOp<spirv::TosaRescaleOp>(
+        op, convertType(op.getType()), scale32, roundingMode, perChannel,
+        inputUnsigned, outputUnsigned, input, multiplier, shift, inputZp,
+        outputZp);
+    return success();
+  }
+};
+
+struct TosaConstConvert final : public TosaOpConversionPattern<tosa::ConstOp> {
+  using TosaOpConversionPattern<tosa::ConstOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ConstOp op, tosa::ConstOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    if (op->use_empty()) {
+      rewriter.eraseOp(op);
+      return success();
+    }
+
+    auto graphConstId = getGraphIdForConst(op);
+    if (graphConstId.has_value()) {
+      rewriter.replaceOpWithNewOp<spirv::GraphConstantARMOp>(
+          op, convertType(op.getType()), graphConstId.value());
+      return success();
+    }
+
+    ElementsAttr convertedValue;
+    if (maybeConvertValue(op.getLoc(), adaptor.getValues(), convertedValue)
+            .failed()) {
+      return failure();
+    }
+    rewriter.replaceOpWithNewOp<spirv::ConstantOp>(
+        op, convertType(op.getType()), convertedValue);
+
+    return success();
+  }
+};
+
+struct TosaIdentityConvert final
+    : public TosaOpConversionPattern<tosa::IdentityOp> {
+  using TosaOpConversionPattern<tosa::IdentityOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::IdentityOp op, tosa::IdentityOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    rewriter.replaceOp(op, adaptor.getInput1());
+    return success();
+  }
+};
+
+struct TosaConstShapeConvert final
+    : public TosaOpConversionPattern<tosa::ConstShapeOp> {
+  using TosaOpConversionPattern<tosa::ConstShapeOp>::TosaOpConversionPattern;
+
+  LogicalResult
+  matchAndRewrite(tosa::ConstShapeOp op, tosa::ConstShapeOpAdaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+
+    if (op->use_empty()) {
+      rewriter.eraseOp(op);
+      return success();
+    }
+
+    auto graphConstId = getGraphIdForConst(op);
+    if (graphConstId.has_value()) {
+      rewriter.replaceOpWithNewOp<spirv::GraphConstantARMOp>(
+          op, convertType(op.getType()), graphConstId.value());
+      return success();
+    }
+
+    ElementsAttr convertedValue;
+    if (maybeConvertValue(op.getLoc(), adaptor.getValues(), convertedValue)
+            .failed()) {
+      return failure();
+    }
+    rewriter.replaceOpWithNewOp<spirv::ConstantOp>(
+        op, convertType(op.getType()), convertedValue);
+
+    return success();
+  }
+};
+
+} // namespace
+
+void mlir::tosa::populateTosaToSPIRVOpsConversionPatterns(
+    SPIRVTypeConverter &typeConverter, RewritePatternSet &patterns) {
+  patterns.add<
+      TosaArgMaxConvert, TosaAvgPool2DConvert, TosaConv2DConvert,
+      TosaConv3DConvert, TosaDepthwiseConv2DConvert, TosaFFT2DConvert,
+      TosaMatMulConvert, TosaMaxPool2DConvert, TosaRFFT2DConvert,
+      TosaTransposeConv2DConvert, TosaClampConvert, TosaErfConvert,
+      TosaSigmoidConvert, TosaTanhConvert, TosaAddConvert,
+      TosaArithmeticRightShiftConvert, TosaBitwiseAndConvert,
+      TosaBitwiseOrConvert, TosaBitwiseXorConvert, TosaIntDivConvert,
+      TosaLogicalAndConvert, TosaLogicalLeftShiftConvert,
+      TosaLogicalRightShiftConvert, TosaLogicalOrConvert, TosaLogicalXorConvert,
+      TosaMaximumConvert, TosaMinimumConvert, TosaMulConvert, TosaPowConvert,
+      TosaSubConvert, TosaTableConvert, TosaAbsConvert, TosaBitwiseNotConvert,
+      TosaCeilConvert, TosaClzConvert, TosaCosConvert, TosaExpConvert,
+      TosaFloorConvert, TosaLogConvert, TosaLogicalNotConvert,
+      TosaNegateConvert, TosaReciprocalConvert, TosaRsqrtConvert,
+      TosaSinConvert, TosaSelectConvert, TosaEqualConvert, TosaGreaterConvert,
+      TosaGreaterEqualConvert, TosaReduceAllConvert, TosaReduceAnyConvert,
+      TosaReduceMaxConvert, TosaReduceMinConvert, TosaReduceProductConvert,
+      TosaReduceSumConvert, TosaConcatConvert, TosaPadConvert,
+      TosaReshapeConvert, TosaReverseConvert, TosaSliceConvert, TosaTileConvert,
+      TosaTransposeConvert, TosaGatherConvert, TosaScatterConvert,
+      TosaResizeConvert, TosaCastConvert, TosaRescaleConvert, TosaConstConvert,
+      TosaIdentityConvert, TosaConstShapeConvert>(typeConverter,
+                                                  patterns.getContext());
+}
diff --git a/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRVPass.cpp b/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRVPass.cpp
new file mode 100644
index 000000000000..b878619bbed9
--- /dev/null
+++ b/mlir/lib/Conversion/TosaToSPIRV/TosaToSPIRVPass.cpp
@@ -0,0 +1,177 @@
+//===- TosaToSPIRVPass.cpp - Lowering Tosa to SPIR-V Dialect --------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This transformation pass legalizes Tosa operations to the SPIR-V dialect.
+//
+//===----------------------------------------------------------------------===//
+
+#include "mlir/Conversion/TosaToSPIRV/TosaToSPIRV.h"
+
+#include "mlir/Dialect/Func/IR/FuncOps.h"
+#include "mlir/Dialect/SPIRV/IR/SPIRVDialect.h"
+#include "mlir/Dialect/SPIRV/Transforms/SPIRVConversion.h"
+#include "mlir/Dialect/Tosa/IR/TosaOps.h"
+#include "mlir/Dialect/Tosa/Transforms/Passes.h"
+#include "mlir/IR/TypeUtilities.h"
+#include "mlir/Pass/PassManager.h"
+#include "mlir/Transforms/DialectConversion.h"
+#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
+
+namespace mlir {
+#define GEN_PASS_DEF_TOSATOSPIRV
+#include "mlir/Conversion/Passes.h.inc"
+} // namespace mlir
+
+using namespace mlir;
+using namespace tosa;
+
+namespace {
+
+spirv::VerCapExtAttr getVerCapExtAttr(MLIRContext *context) {
+  return spirv::VerCapExtAttr::get(
+      spirv::Version::V_1_5,
+      {
+          spirv::Capability::VulkanMemoryModel,
+          spirv::Capability::Shader,
+          spirv::Capability::Int8,
+          spirv::Capability::Int16,
+          spirv::Capability::Int64,
+          spirv::Capability::Float16,
+          spirv::Capability::TensorsARM,
+          spirv::Capability::GraphARM,
+          spirv::Capability::ReplicatedCompositesEXT,
+      },
+      {
+          spirv::Extension::SPV_ARM_tensors,
+          spirv::Extension::SPV_ARM_graph,
+          spirv::Extension::SPV_KHR_vulkan_memory_model,
+          spirv::Extension::SPV_EXT_replicated_composites,
+          spirv::Extension::SPV_KHR_non_semantic_info,
+      },
+      context);
+}
+
+struct TosaToSPIRV : public impl::TosaToSPIRVBase<TosaToSPIRV> {
+public:
+  TosaToSPIRV(bool analysis = false) : analysis(analysis) {}
+
+  void runOnOperation() override {
+    MLIRContext *context = &getContext();
+    RewritePatternSet patterns(context);
+    Operation *op = getOperation();
+
+    auto targetAttr = spirv::lookupTargetEnv(op);
+    if (!targetAttr) {
+      targetAttr = spirv::TargetEnvAttr::get(
+          getVerCapExtAttr(context), spirv::getDefaultResourceLimits(context),
+          spirv::ClientAPI::Unknown, spirv::Vendor::Unknown,
+          spirv::DeviceType::Unknown, spirv::TargetEnvAttr::kUnknownDeviceID);
+    }
+
+    std::unique_ptr<ConversionTarget> target =
+        SPIRVConversionTarget::get(targetAttr);
+
+    target->addLegalDialect<spirv::SPIRVDialect>();
+    target->addIllegalDialect<tosa::TosaDialect>();
+
+    SPIRVTypeConverter typeConverter(targetAttr);
+    typeConverter.addConversion([this](IntegerType integerType) {
+      return this->convertIntegerType(integerType);
+    });
+    typeConverter.addConversion([this](TensorType tensorType) {
+      return this->convertTensorType(tensorType);
+    });
+    typeConverter.addConversion([this](tosa::shapeType shapeType) {
+      return this->convertShapeType(shapeType);
+    });
+
+    populateTosaToSPIRVConversionPatterns(typeConverter, patterns);
+    populateTosaToSPIRVOpsConversionPatterns(typeConverter, patterns);
+
+    auto targetEnvAttrName = spirv::getTargetEnvAttrName();
+    auto symbolTableOp = SymbolTable::getNearestSymbolTable(op);
+    if (symbolTableOp && !symbolTableOp->hasAttrOfType<spirv::TargetEnvAttr>(
+                             targetEnvAttrName)) {
+      symbolTableOp->setAttr(targetEnvAttrName, targetAttr);
+    }
+
+    FrozenRewritePatternSet frozenPatterns(std::move(patterns));
+
+    if (analysis) {
+      DenseSet<Operation *> convertedOps;
+      ConversionConfig config;
+      config.legalizableOps = &convertedOps;
+      if (failed(applyAnalysisConversion(op, *target, frozenPatterns, config)))
+        signalPassFailure();
+
+      for (Operation *op : convertedOps) {
+        if (llvm::isa<TosaDialect>(op->getDialect())) {
+          llvm::errs() << "Successfully lowered: " << op->getName() << " at "
+                       << op->getLoc() << "\n";
+        }
+      }
+    }
+
+    if (failed(applyPartialConversion(op, *target, frozenPatterns))) {
+      signalPassFailure();
+    }
+  }
+
+private:
+  bool analysis;
+
+  IntegerType convertIntegerType(IntegerType integerType) {
+    if (integerType.getWidth() == 48) {
+      return IntegerType::get(&getContext(), 64, integerType.getSignedness());
+    }
+
+    if (integerType.getWidth() == 4) {
+      return IntegerType::get(&getContext(), 8, integerType.getSignedness());
+    }
+
+    return integerType;
+  }
+
+  SmallVector<int64_t> convertShape(ArrayRef<int64_t> shape) {
+    bool requiresRankConversion =
+        llvm::all_of(shape, [](int64_t dim) { return dim == 0; });
+    if (requiresRankConversion)
+      return SmallVector<int64_t>({1});
+    bool isPartiallyDynamic =
+        llvm::any_of(shape, [](int64_t dim) { return dim < 0; }) &&
+        llvm::any_of(shape, [](int64_t dim) { return dim > 0; });
+    if (isPartiallyDynamic)
+      return SmallVector<int64_t>(shape.size(), ShapedType::kDynamic);
+    return SmallVector<int64_t>(shape);
+  }
+
+  spirv::TensorArmType convertTensorType(TensorType tensorType) {
+    Type elementType = getElementTypeOrSelf(tensorType);
+    if (elementType.isIndex())
+      elementType = IntegerType::get(&getContext(), 32);
+    if (auto integerType = dyn_cast<IntegerType>(elementType))
+      elementType = convertIntegerType(integerType);
+
+    SmallVector<int64_t> shape = tensorType.hasRank()
+                                     ? convertShape(tensorType.getShape())
+                                     : SmallVector<int64_t>();
+
+    return spirv::TensorArmType::get(shape, elementType);
+  }
+
+  spirv::TensorArmType convertShapeType(tosa::shapeType shapeType) {
+    const auto rank = std::max(shapeType.getRank(), 1);
+    return spirv::TensorArmType::get({rank},
+                                     IntegerType::get(&getContext(), 32));
+  }
+};
+} // namespace
+
+std::unique_ptr<Pass> mlir::tosa::createTosaToSPIRV(bool analysis) {
+  return std::make_unique<TosaToSPIRV>(analysis);
+}
diff --git a/mlir/lib/Dialect/SPIRV/IR/CMakeLists.txt b/mlir/lib/Dialect/SPIRV/IR/CMakeLists.txt
index 60d705d940cf..ec3ab4045afa 100644
--- a/mlir/lib/Dialect/SPIRV/IR/CMakeLists.txt
+++ b/mlir/lib/Dialect/SPIRV/IR/CMakeLists.txt
@@ -24,6 +24,7 @@ add_mlir_dialect_library(MLIRSPIRVDialect
   SPIRVParsingUtils.cpp
   SPIRVTypes.cpp
   TargetAndABI.cpp
+  TosaOps.cpp
 
   ADDITIONAL_HEADER_DIRS
   ${MLIR_MAIN_INCLUDE_DIR}/mlir/Dialect/SPIRV
diff --git a/mlir/lib/Dialect/SPIRV/IR/TosaOps.cpp b/mlir/lib/Dialect/SPIRV/IR/TosaOps.cpp
new file mode 100644
index 000000000000..f53fbd393873
--- /dev/null
+++ b/mlir/lib/Dialect/SPIRV/IR/TosaOps.cpp
@@ -0,0 +1,1133 @@
+//===- TosaOps.cpp - MLIR SPIR-V operations -------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the Tosa operations in the SPIR-V dialect.
+//
+//===----------------------------------------------------------------------===//
+
+#include "mlir/Dialect/SPIRV/IR/SPIRVOps.h"
+
+#include "mlir/IR/BuiltinTypes.h"
+#include "mlir/IR/TypeUtilities.h"
+
+using namespace mlir;
+
+//===----------------------------------------------------------------------===//
+// TOSA Operator Verifiers.
+//===----------------------------------------------------------------------===//
+
+// Get value attr from spirv::ConstantOp or
+// spirv::EXTConstantCompositeReplicateOp
+template <typename TAttr>
+static LogicalResult getConstAttr(Value value, TAttr &valAttr) {
+  if (auto constOp = value.template getDefiningOp<spirv::ConstantOp>()) {
+    valAttr = dyn_cast<TAttr>(constOp.getValue());
+  } else if (auto constCompositeReplicateOp =
+                 value.template getDefiningOp<
+                     spirv::EXTConstantCompositeReplicateOp>()) {
+    auto splatAttr = constCompositeReplicateOp.getValue();
+    auto denseValAttr = SplatElementsAttr::get(
+        cast<ShapedType>(constCompositeReplicateOp.getType()), splatAttr);
+    valAttr = dyn_cast<TAttr>(denseValAttr);
+  }
+
+  return valAttr ? success() : failure();
+}
+
+template <typename T, typename TAdaptor>
+static LogicalResult verifyConvOp(T op, TAdaptor adaptor) {
+  auto inputTy = cast<ShapedType>(op.getInput().getType());
+  auto weightTy = cast<ShapedType>(op.getWeight().getType());
+  auto biasTy = cast<ShapedType>(op.getBias().getType());
+  auto resultTy = cast<ShapedType>(op.getType());
+
+  if constexpr (std::is_same_v<T, spirv::TosaConv3DOp>) {
+    if (inputTy.hasRank() && inputTy.getRank() != 5) {
+      return op.emitOpError("input rank must be 5");
+    }
+
+    if (weightTy.hasRank() && weightTy.getRank() != 5) {
+      return op.emitOpError("weight rank must be 5");
+    }
+
+    if (resultTy.hasRank() && resultTy.getRank() != 5) {
+      return op.emitOpError("result rank must be 5");
+    }
+  } else {
+    if (inputTy.getRank() != 4) {
+      return op.emitOpError("input rank must be 4");
+    }
+
+    if (weightTy.hasRank() && weightTy.getRank() != 4) {
+      return op.emitOpError("weight rank must be 4");
+    }
+
+    if (resultTy.hasRank() && resultTy.getRank() != 4) {
+      return op.emitOpError("result rank must be 4");
+    }
+  }
+
+  if (biasTy.hasRank() && biasTy.getRank() != 1) {
+    return op.emitOpError("bias rank must be 1");
+  }
+
+  auto inputETy = inputTy.getElementType();
+  auto weightETy = weightTy.getElementType();
+  auto biasETy = biasTy.getElementType();
+  auto resultETy = resultTy.getElementType();
+
+  if (inputETy.isInteger(8) && !resultETy.isInteger(32)) {
+    return op.emitOpError("expect result type to be i32, got ") << resultETy;
+  }
+
+  if (inputETy.isInteger(16) && !resultETy.isInteger(64)) {
+    return op.emitOpError("expect result type to be i64, got ") << resultETy;
+  }
+
+  if (inputETy.isF16() && !resultETy.isF16()) {
+    return op.emitOpError("expect result type to be f16, got ") << resultETy;
+  }
+
+  if (inputETy.isF32() && !resultETy.isF32()) {
+    return op.emitOpError("expect result type to be f32, got ") << resultETy;
+  }
+
+  if (biasETy != resultETy) {
+    return op.emitOpError("element types of bias and result must be the same");
+  }
+
+  DenseIntOrFPElementsAttr inputZpAttr;
+  if (getConstAttr(adaptor.getInputZp(), inputZpAttr).failed()) {
+    return op.emitOpError(
+        "input_zp must be a tensorARM of an integer/float constant");
+  }
+
+  if (inputZpAttr.size() != 1) {
+    return op.emitOpError("input_zp must have a single element");
+  }
+
+  auto inputZpETy = inputZpAttr.getElementType();
+  if (inputZpETy != inputETy) {
+    return op.emitOpError(
+        "element types of input_zp and input must be the same");
+  }
+
+  DenseIntOrFPElementsAttr weightZpAttr;
+  if (getConstAttr(adaptor.getWeightZp(), weightZpAttr).failed()) {
+    return op.emitOpError(
+        "weight_zp must be a tensorARM of an integer/float constant");
+  }
+
+  if (weightZpAttr.size() != 1) {
+    return op.emitOpError("weight_zp must have a single element");
+  }
+
+  auto weightZpETy = weightZpAttr.getElementType();
+  if (weightZpETy != weightETy) {
+    return op.emitOpError(
+        "element types of weight_zp and weight must be the same");
+  }
+
+  if (isa<IntegerType>(inputZpETy)) {
+    if ((inputZpETy.getIntOrFloatBitWidth() != 8) &&
+        !inputZpAttr.getValues<APInt>()[0].isZero()) {
+      return op.emitOpError(
+          "input_zp element value must be zero for non-int8 types.");
+    }
+  } else {
+    if (!inputZpAttr.getValues<APFloat>()[0].isZero()) {
+      return op.emitOpError(
+          "input_zp element value must be zero for non-int8 types.");
+    }
+  }
+
+  if (isa<IntegerType>(weightZpETy)) {
+    if ((weightZpETy.getIntOrFloatBitWidth() != 8) &&
+        !weightZpAttr.getValues<APInt>()[0].isZero()) {
+      return op.emitOpError(
+          "weight_zp element value must be zero for non-int8 types.");
+    }
+  } else {
+    if (!weightZpAttr.getValues<APFloat>()[0].isZero()) {
+      return op.emitOpError(
+          "weight_zp element value must be zero for non-int8 types.");
+    }
+  }
+
+  BoolAttr localBoundAttr;
+  if ((getConstAttr(adaptor.getLocalBound(), localBoundAttr).failed())) {
+    return op.emitOpError("local bound must be a constant boolean");
+  }
+
+  return success();
+}
+
+template <typename T>
+static LogicalResult verifyConvOpModes(T op) {
+  IntegerAttr accTypeAttr;
+  if (getConstAttr(op.getAccType(), accTypeAttr).failed()) {
+    return op.emitOpError("accumulator type must be a constant integer");
+  }
+
+  int accType = accTypeAttr.getInt();
+  if (accType != 1 && accType != 2 && accType != 3 && accType != 4) {
+    return op.emitOpError("accumulator type can only have values 1/2/3/4 "
+                          "corresponding to i32/f16/f32/i48");
+  }
+
+  auto inputTy = cast<ShapedType>(op.getInput().getType());
+  auto inputETy = inputTy.getElementType();
+
+  if (inputETy.isInteger(8) && accType != 1) {
+    return op.emitOpError("accumulator type for i8 tensorARM is not i32");
+  }
+
+  if (inputETy.isInteger(16) && accType != 4) {
+    return op.emitOpError("accumulator type for i16 tensorARM is not i48");
+  }
+
+  if (inputETy.isF16() && !(accType == 2 || accType == 3)) {
+    return op.emitOpError(
+        "accumulator type for f16 tensorARM is not f16 or f32");
+  }
+
+  if (inputETy.isBF16() && accType != 3) {
+    return op.emitOpError("accumulator type for bf16 tensorARM is not f32");
+  }
+
+  if (inputETy.isF32() && accType != 3) {
+    return op.emitOpError("accumulator type for f32 tensorARM is not f32");
+  }
+
+  return success();
+}
+
+// Verify that inType and outType have same element types
+template <typename TOp>
+static LogicalResult verifySameElementTypes(TOp op, Type inType, Type outType) {
+  auto inputType = dyn_cast<ShapedType>(inType);
+  auto outputType = dyn_cast<ShapedType>(outType);
+
+  if (!inputType) {
+    op.emitOpError("expect shaped tensorARM for input, got ") << inType;
+    return failure();
+  }
+  if (!outputType) {
+    op.emitOpError("expect shaped tensorARM for output, got ") << outType;
+    return failure();
+  }
+  auto inputElementType = inputType.getElementType();
+  auto outputElementType = outputType.getElementType();
+
+  if (inputElementType != outputElementType) {
+    op.emitOpError("expect input and output to have same element type, got ")
+        << inputElementType << " and " << outputElementType;
+    return failure();
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaArgmaxOp
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaArgMaxOp::verify() {
+  auto inputTy = cast<ShapedType>(getInput().getType());
+  auto resultTy = cast<ShapedType>(getType());
+
+  if (inputTy.hasRank() && resultTy.hasRank() &&
+      resultTy.getRank() !=
+          (inputTy.getRank() > 1 ? inputTy.getRank() - 1 : 1)) {
+    return emitOpError("result rank must be max of 1 and (input rank - 1)");
+  }
+
+  auto resultETy = resultTy.getElementType();
+  if (!resultETy.isIntOrIndex()) {
+    return emitOpError("result is not of integer type");
+  }
+
+  IntegerAttr axisAttr;
+  if (getConstAttr(getAxis(), axisAttr).failed()) {
+    return emitOpError("axis type must be a constant integer");
+  }
+
+  const int axis = axisAttr.getInt();
+  if (inputTy.hasRank() && ((axis < 0) || axis >= inputTy.getRank())) {
+    return emitOpError("specified axis is outside the rank of input");
+  }
+
+  IntegerAttr nanModeAttr;
+  if (getConstAttr(getNanMode(), nanModeAttr).failed()) {
+    return emitOpError("nan_mode type must be a constant integer");
+  }
+
+  int nanMode = nanModeAttr.getInt();
+  if (nanMode != 1 && nanMode != 2) {
+    return emitOpError("nan_mode can only have values 1 and 2 corresponding to "
+                       "PROPAGATE/IGNORE");
+  }
+
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaAvgPool2DOp
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaAvgPool2DOp::verify() {
+  auto inputTy = cast<ShapedType>(getInput().getType());
+  if (inputTy.hasRank() && inputTy.getRank() != 4) {
+    return emitOpError("input rank must be 4");
+  }
+
+  auto resultTy = cast<ShapedType>(getType());
+  if (resultTy.hasRank() && resultTy.getRank() != 4) {
+    return emitOpError("result rank must be 4");
+  }
+
+  IntegerAttr accTypeAttr;
+  if (getConstAttr(getAccType(), accTypeAttr).failed()) {
+    return emitOpError("accumulator type must be a constant integer");
+  }
+
+  int accType = accTypeAttr.getInt();
+  if (accType != 1 && accType != 2 && accType != 3) {
+    return emitOpError("accumulator type can only have values 1/2/3 "
+                       "corresponding to i32/f16/f32");
+  }
+
+  auto inputETy = inputTy.getElementType();
+  auto resultETy = resultTy.getElementType();
+
+  if (isa<IntegerType>(inputETy) && accType != 1) {
+    return emitOpError("accumulator type for integer tensorARM is not i32");
+  }
+
+  if (inputETy.isF16() && !(accType == 2 || accType == 3)) {
+    return emitOpError("accumulator type for f16 tensorARM is not f16/f32");
+  }
+
+  if (inputETy.isF32() && accType != 3) {
+    return emitOpError("accumulator type for f32 tensorARM is not f32");
+  }
+
+  if (inputETy != resultETy) {
+    return emitOpError("input and output element types must be the same");
+  }
+
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaConv2DOp
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaConv2DOp::verify() {
+  if (verifyConvOp(*this, TosaConv2DOp::Adaptor(*this)).failed() ||
+      verifyConvOpModes(*this).failed())
+    return failure();
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaConv3DOp
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaConv3DOp::verify() {
+  if (verifyConvOp(*this, TosaConv3DOp::Adaptor(*this)).failed() ||
+      verifyConvOpModes(*this).failed())
+    return failure();
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// SPIRV Tosa DepthwiseConv2D Ops:
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaDepthwiseConv2DOp::verify() {
+  if (verifyConvOp(*this, TosaDepthwiseConv2DOp::Adaptor(*this)).failed() ||
+      verifyConvOpModes(*this).failed())
+    return failure();
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaFFT2DOp
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaFFT2DOp::verify() {
+  auto inputRealTy = cast<ShapedType>(getInputReal().getType());
+  auto inputImagTy = cast<ShapedType>(getInputImag().getType());
+  auto resultTy = cast<StructType>(getType());
+  auto resultRealTy = cast<ShapedType>(resultTy.getElementType(0));
+  auto resultImagTy = cast<ShapedType>(resultTy.getElementType(1));
+
+  if (inputRealTy.hasRank() && inputRealTy.getRank() != 3) {
+    return emitOpError("real input rank must be 3");
+  }
+
+  if (inputImagTy.hasRank() && inputImagTy.getRank() != 3) {
+    return emitOpError("imaginary input rank must be 3");
+  }
+
+  if (resultRealTy.hasRank() && resultRealTy.getRank() != 3) {
+    return emitOpError("real result rank must be 3");
+  }
+
+  if (resultImagTy.hasRank() && resultImagTy.getRank() != 3) {
+    return emitOpError("imaginary result rank must be 3");
+  }
+
+  if (inputRealTy != inputImagTy || inputRealTy != resultRealTy ||
+      inputImagTy != resultImagTy) {
+    return emitOpError("real input type, imaginary input type, and types of "
+                       "real and imaginary parts of result must be the same");
+  }
+
+  BoolAttr inverseAttr;
+  if ((getConstAttr(getInverse(), inverseAttr).failed())) {
+    return emitOpError("inverse must be a constant boolean");
+  }
+
+  BoolAttr localBoundAttr;
+  if ((getConstAttr(getLocalBound(), localBoundAttr).failed())) {
+    return emitOpError("local bound must be a constant boolean");
+  }
+
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaMatMulOp
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaMatMulOp::verify() {
+  auto aTy = cast<ShapedType>(getA().getType());
+  auto bTy = cast<ShapedType>(getB().getType());
+  auto resultTy = cast<ShapedType>(getType());
+
+  if (!aTy || !bTy) {
+    return emitOpError("expected shaped tensors for inputs, got ")
+           << getA().getType() << " and " << getB().getType();
+  }
+
+  if (aTy.hasRank() && aTy.getRank() != 3) {
+    return emitOpError("A rank must be 3");
+  }
+
+  if (bTy.hasRank() && bTy.getRank() != 3) {
+    return emitOpError("B rank must be 3");
+  }
+
+  if (resultTy.hasRank() && resultTy.getRank() != 3) {
+    return emitOpError("result rank must be 3");
+  }
+
+  auto aETy = aTy.getElementType();
+  auto bETy = bTy.getElementType();
+  auto resultETy = resultTy.getElementType();
+
+  if (aETy != bETy) {
+    return emitOpError("expect same element type for inputs a and b, got ")
+           << aETy << " and " << bETy;
+  }
+
+  if (aETy.isInteger(8) && !resultETy.isInteger(32)) {
+    return emitOpError("expect result element type to be i32, got ")
+           << resultETy;
+  }
+
+  if (aETy.isInteger(16) && !resultETy.isInteger(64)) {
+    return emitOpError("expect result element type to be i64, got ")
+           << resultETy;
+  }
+
+  if (aETy.isF16() && !(resultETy.isF16() || resultETy.isF32())) {
+    return emitOpError("expect result element type to be f16 or f32, got ")
+           << resultETy;
+  }
+
+  if (aETy.isF32() && !resultETy.isF32()) {
+    return emitOpError("expect result element type to be f32, got ")
+           << resultETy;
+  }
+
+  DenseIntOrFPElementsAttr aZpAttr;
+  if (getConstAttr(getAZp(), aZpAttr).failed()) {
+    return emitOpError("a_zp must be a tensorARM of an integer/float constant");
+  }
+
+  if (aZpAttr.size() != 1) {
+    return emitOpError("a_zp must have a single element");
+  }
+
+  DenseIntOrFPElementsAttr bZpAttr;
+  if (getConstAttr(getBZp(), bZpAttr).failed()) {
+    return emitOpError("b_zp must be a tensorARM of an integer/float constant");
+  }
+
+  if (bZpAttr.size() != 1) {
+    return emitOpError("b_zp must have a single element");
+  }
+
+  if (isa<IntegerType>(aETy)) {
+    if ((aETy.getIntOrFloatBitWidth() != 8) &&
+        (!aZpAttr.getValues<APInt>()[0].isZero() ||
+         !bZpAttr.getValues<APInt>()[0].isZero())) {
+      return emitOpError("a_zp and b_zp must be zero for non-int8 types.");
+    }
+  } else {
+    if (!aZpAttr.getValues<APFloat>()[0].isZero() ||
+        !bZpAttr.getValues<APFloat>()[0].isZero()) {
+      return emitOpError("a_zp and b_zp must be zero for non-int8 types.");
+    }
+  }
+
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaMaxPool2DOp
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaMaxPool2DOp::verify() {
+  auto inputTy = cast<ShapedType>(getInput().getType());
+  auto resultTy = cast<ShapedType>(getType());
+
+  if (inputTy.hasRank() && inputTy.getRank() != 4) {
+    return emitOpError("input rank must be 4");
+  }
+
+  if (resultTy.hasRank() && resultTy.getRank() != 4) {
+    return emitOpError("result rank must be 4");
+  }
+
+  IntegerAttr nanModeAttr;
+  if (getConstAttr(getNanMode(), nanModeAttr).failed()) {
+    return emitOpError("nan_mode type must be a constant integer");
+  }
+
+  int nanMode = nanModeAttr.getInt();
+  if (nanMode != 1 && nanMode != 2) {
+    return emitOpError("nan_mode can only have values 1 and 2 corresponding to "
+                       "PROPAGATE/IGNORE");
+  }
+
+  return verifySameElementTypes(*this, getInput().getType(),
+                                getOutput().getType());
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaRFFT2DOp
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaRFFT2DOp::verify() {
+  auto inputTy = cast<ShapedType>(getInputReal().getType());
+  auto resultTy = cast<StructType>(getType());
+  auto resultRealTy = cast<ShapedType>(resultTy.getElementType(0));
+  auto resultImagTy = cast<ShapedType>(resultTy.getElementType(1));
+
+  if (inputTy.hasRank() && inputTy.getRank() != 3) {
+    return emitOpError("input rank must be 3");
+  }
+
+  if (resultRealTy.hasRank() && resultRealTy.getRank() != 3) {
+    return emitOpError("real result rank must be 3");
+  }
+
+  if (resultImagTy.hasRank() && resultImagTy.getRank() != 3) {
+    return emitOpError("imaginary result rank must be 3");
+  }
+
+  if (inputTy.getElementType() != resultRealTy.getElementType() ||
+      inputTy.getElementType() != resultImagTy.getElementType()) {
+    return emitOpError(
+        "input element type and element types of real and imaginary parts of "
+        "result must be the same");
+  }
+
+  BoolAttr localBoundAttr;
+  if ((getConstAttr(getLocalBound(), localBoundAttr).failed())) {
+    return emitOpError("local bound must be a constant boolean");
+  }
+
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// SPIRV Tosa TransposeConv2D Ops:
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaTransposeConv2DOp::verify() {
+  if (verifyConvOp(*this, TosaTransposeConv2DOp::Adaptor(*this)).failed() ||
+      verifyConvOpModes(*this).failed())
+    return failure();
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaMulOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaMulOp::verify() {
+  auto resElemType = getElementTypeOrSelf(getOutput());
+
+  // Verify if the element type amoung operands and result match tosa
+  // specification.
+  if (auto resIntType = dyn_cast<IntegerType>(resElemType)) {
+    IntegerType lhsIntType =
+        cast<IntegerType>(getElementTypeOrSelf(getInput1()));
+    IntegerType rhsIntType =
+        cast<IntegerType>(getElementTypeOrSelf(getInput2()));
+    if (lhsIntType != rhsIntType)
+      return emitOpError(
+          "requires the same element type for all input operands");
+
+    // Though the spec requires the element type of result to be i32, a more
+    // relaxed way is provided at dialect level for easier cooperating with
+    // other dialects.
+    if (lhsIntType.getWidth() > resIntType.getWidth())
+      return emitOpError("invalid data type size for operands or result");
+  } else {
+    // For other supported type, the spec requires requires the same element
+    // type for all operands (excludes `shift` operand) and results.
+    for (int i = 0; i < 2; ++i) {
+      if (getElementTypeOrSelf(getOperand(i)) != resElemType)
+        return emitOpError(
+            "requires the same element type for all operands and results");
+    }
+  }
+
+  auto compareRank = [](const ShapedType type, const ShapedType against) {
+    return type.hasRank() && against.hasRank() &&
+           type.getRank() == against.getRank();
+  };
+  ShapedType opType = cast<ShapedType>(getType());
+  for (int i = 0; i < 2; ++i) {
+    if (!compareRank(cast<ShapedType>(getOperand(i).getType()), opType))
+      return emitOpError("result type has different rank than operands");
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaCastOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaCastOp::verify() {
+  auto inputETy = cast<ShapedType>(getInput().getType()).getElementType();
+  auto outputETy = cast<ShapedType>(getType()).getElementType();
+
+  // input element type: bool
+  if (inputETy.isInteger(1)) {
+    if (outputETy.isInteger(8) || outputETy.isInteger(16) ||
+        outputETy.isInteger(32)) {
+      return success();
+    }
+  }
+  // input element type: int8
+  if (inputETy.isInteger(8)) {
+    if (outputETy.isInteger(1) || outputETy.isInteger(16) ||
+        outputETy.isInteger(32) || outputETy.isF16() || outputETy.isBF16() ||
+        outputETy.isF32()) {
+      return success();
+    }
+  }
+  // input element type: int16
+  if (inputETy.isInteger(16)) {
+    if (outputETy.isInteger(1) || outputETy.isInteger(8) ||
+        outputETy.isInteger(32) || outputETy.isF16() || outputETy.isBF16() ||
+        outputETy.isF32()) {
+      return success();
+    }
+  }
+  // input element type: int32
+  if (inputETy.isInteger(32)) {
+    if (outputETy.isInteger(1) || outputETy.isInteger(8) ||
+        outputETy.isInteger(16) || outputETy.isF16() || outputETy.isBF16() ||
+        outputETy.isF32()) {
+      return success();
+    }
+  }
+  // input element type: bf16 or fp16
+  if (inputETy.isBF16() || inputETy.isF16()) {
+    if (outputETy.isInteger(8) || outputETy.isInteger(16) ||
+        outputETy.isInteger(32) || outputETy.isF32()) {
+      return success();
+    }
+  }
+  // input element type: fp32
+  if (inputETy.isF32()) {
+    if (outputETy.isInteger(8) || outputETy.isInteger(16) ||
+        outputETy.isInteger(32) || outputETy.isF16() || outputETy.isBF16()) {
+      return success();
+    }
+  }
+
+  return emitOpError("input/output element types are incompatible: ")
+         << inputETy << " and " << outputETy;
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaClampOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaClampOp::verify() {
+  auto inputETy = cast<ShapedType>(getInput().getType()).getElementType();
+  auto outputETy = cast<ShapedType>(getOutput().getType()).getElementType();
+
+  if (inputETy != outputETy)
+    return emitOpError("input/output element types are incompatible");
+
+  unsigned dataTypeBitWidth = inputETy.getIntOrFloatBitWidth();
+
+  if (inputETy.isInteger(dataTypeBitWidth)) {
+    IntegerAttr minValAttr, maxValAttr;
+    if ((getConstAttr(getMinVal(), minValAttr).failed()) ||
+        (getConstAttr(getMaxVal(), maxValAttr).failed()) ||
+        (minValAttr.getType() != maxValAttr.getType()) ||
+        (minValAttr.getType() != inputETy))
+
+      return emitOpError("min/max attributes types are incompatible with "
+                         "input/output element types.");
+  } else {
+    FloatAttr minValAttr, maxValAttr;
+    if ((getConstAttr(getMinVal(), minValAttr).failed()) ||
+        (getConstAttr(getMaxVal(), maxValAttr).failed()) ||
+        (minValAttr.getType() != maxValAttr.getType()) ||
+        (minValAttr.getType() != inputETy))
+
+      return emitOpError("min/max attributes types are incompatible with "
+                         "input/output element types.");
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaConcatOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaConcatOp::verify() {
+  auto outType = getOutput().getType();
+  for (auto input : getInput1()) {
+    if (verifySameElementTypes(*this, input.getType(), outType).failed()) {
+      return failure();
+    }
+  }
+  IntegerAttr axisAttr;
+  if (getConstAttr(getAxis(), axisAttr).failed()) {
+    return emitOpError("Axis must be an integer constant");
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaPadOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaPadOp::verify() {
+  if (verifySameElementTypes(*this, getInput1().getType(),
+                             getOutput().getType())
+          .failed()) {
+    return failure();
+  }
+
+  auto inputETy = cast<ShapedType>(getInput1().getType()).getElementType();
+
+  DenseIntOrFPElementsAttr padConstAttr;
+  if ((getConstAttr(getPadConst(), padConstAttr).failed()) ||
+      (padConstAttr.getElementType() != inputETy)) {
+    return emitOpError(
+        "PadConst element type is not same as input element type.");
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaSliceOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaSliceOp::verify() {
+  auto inputTy = cast<ShapedType>(getInput1().getType());
+  auto outputTy = cast<ShapedType>(getOutput().getType());
+  auto startTy = cast<ShapedType>(getStart().getType());
+  auto sizeTy = cast<ShapedType>(getSize().getType());
+
+  if (verifySameElementTypes(*this, inputTy, outputTy).failed()) {
+    return failure();
+  }
+
+  if (inputTy.hasRank() && startTy.hasRank() &&
+      startTy.getShape()[0] != ShapedType::kDynamic &&
+      inputTy.getRank() != startTy.getShape()[0]) {
+    return emitOpError("length of start is not equal to rank of input shape");
+  }
+
+  if (inputTy.hasRank() && sizeTy.hasRank() &&
+      sizeTy.getShape()[0] != ShapedType::kDynamic &&
+      inputTy.getRank() != sizeTy.getShape()[0]) {
+    return emitOpError("length of size is not equal to rank of input shape");
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaTileOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaTileOp::verify() {
+  auto inputTy = cast<ShapedType>(getInput1().getType());
+  auto outputTy = cast<ShapedType>(getOutput().getType());
+  auto multiplesTy = cast<ShapedType>(getMultiples().getType());
+
+  if (verifySameElementTypes(*this, inputTy, outputTy).failed()) {
+    return failure();
+  }
+
+  if (inputTy.hasRank() && outputTy.hasRank() &&
+      inputTy.getRank() != outputTy.getRank()) {
+    return emitOpError("expect same input and output tensorARM rank");
+  }
+
+  if (inputTy.hasRank() && multiplesTy.hasRank() &&
+      multiplesTy.getShape()[0] != ShapedType::kDynamic &&
+      inputTy.getRank() != multiplesTy.getShape()[0]) {
+    return emitOpError("expect 'multiples' array to have length ")
+           << inputTy.getRank() << " but got " << multiplesTy.getShape()[0];
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaTransposeOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaTransposeOp::verify() {
+  auto inputTy = cast<ShapedType>(getInput1().getType());
+  auto outputTy = cast<ShapedType>(getOutput().getType());
+  auto permsTy = cast<ShapedType>(getPerms().getType());
+
+  if (verifySameElementTypes(*this, inputTy, outputTy).failed()) {
+    return failure();
+  }
+
+  if (inputTy.hasRank() && outputTy.hasRank() &&
+      inputTy.getRank() != outputTy.getRank()) {
+    return emitOpError("expect same input and output tensorARM rank");
+  }
+
+  if (permsTy.hasRank() && permsTy.getRank() != 1) {
+    return emitOpError(
+               "expected permutation tensorARM to be rank 1 but got rank ")
+           << permsTy.getRank();
+  }
+
+  if (inputTy.hasRank() && permsTy.getShape()[0] != ShapedType::kDynamic &&
+      inputTy.getRank() != permsTy.getShape()[0]) {
+    return emitOpError("expect permutation tensorARM to have length ")
+           << inputTy.getRank() << " but got " << permsTy.getShape()[0];
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaGatherOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaGatherOp::verify() {
+  return verifySameElementTypes(*this, getValues().getType(),
+                                getOutput().getType());
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaScatterOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaScatterOp::verify() {
+  if (verifySameElementTypes(*this, getValuesIn().getType(),
+                             getValuesOut().getType())
+          .failed()) {
+    return failure();
+  }
+  if (verifySameElementTypes(*this, getInput().getType(),
+                             getValuesOut().getType())
+          .failed()) {
+    return failure();
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaRescaleOp
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaRescaleOp::verify() {
+  auto inputTy = cast<ShapedType>(getInput().getType());
+  auto outputTy = cast<ShapedType>(getOutput().getType());
+
+  auto inputETy = inputTy.getElementType();
+  if (!isa<IntegerType>(inputETy)) {
+    return emitOpError("expect input to have integer element type, got ")
+           << inputETy;
+  }
+
+  if (inputTy.hasRank() != outputTy.hasRank() ||
+      (inputTy.hasRank() && inputTy.getShape() != outputTy.getShape())) {
+    return emitOpError("Shape of input and output must be same");
+  }
+
+  auto outputETy = outputTy.getElementType();
+  if (!isa<IntegerType>(outputETy)) {
+    return emitOpError("expect output to have integer element type, got ")
+           << outputETy;
+  }
+
+  DenseIntElementsAttr inputZpAttr;
+  if ((getConstAttr(getInputZp(), inputZpAttr).failed())) {
+    return emitOpError(
+        "input_zp must be single element tensorARM of an integer constant");
+  }
+
+  if (inputZpAttr.size() != 1) {
+    return emitOpError("input_zp must have a single element");
+  }
+
+  auto inputZPETy = inputZpAttr.getElementType();
+  if (inputZPETy != inputETy) {
+    return emitOpError(
+        "input_zp element type is not same as input element type");
+  }
+
+  if (auto inputAPInt = inputZpAttr.getValues<APInt>()[0];
+      !inputAPInt.isZero()) {
+    if (!inputETy.isInteger(8) &&
+        !(inputETy.isInteger(16) && getInputUnsigned())) {
+      return emitOpError("expect input_zp of 0, got ")
+             << inputAPInt.getZExtValue();
+    }
+    if (inputETy.isInteger(16) && getInputUnsigned()) {
+      if (auto input_zp = inputAPInt.getZExtValue(); input_zp != 32768u) {
+        return emitOpError("expect input_zp of 0 or 32768 for unsigned int16 "
+                           "input, got ")
+               << input_zp;
+      }
+    }
+  }
+
+  DenseIntElementsAttr outputZpAttr;
+  if ((getConstAttr(getOutputZp(), outputZpAttr).failed())) {
+    return emitOpError(
+        "output_zp must be single element tensorARM of an integer constant");
+  }
+
+  if (outputZpAttr.size() != 1) {
+    return emitOpError("output_zp must have a single element");
+  }
+
+  auto outputZPETy = outputZpAttr.getElementType();
+  if (outputZPETy != outputETy) {
+    return emitOpError(
+        "output_zp element type is not same as output element type");
+  }
+
+  if (auto outputAPInt = outputZpAttr.getValues<APInt>()[0];
+      !outputAPInt.isZero()) {
+    if (!outputETy.isInteger(8) &&
+        !(outputETy.isInteger(16) && getOutputUnsigned())) {
+      return emitOpError("expect output_zp of 0, got ")
+             << outputAPInt.getZExtValue();
+    }
+    if (outputETy.isInteger(16) && getOutputUnsigned()) {
+      if (auto output_zp = outputAPInt.getZExtValue(); output_zp != 32768u) {
+        return emitOpError("expect output_zp of 0 or 32768 for unsigned int16 "
+                           "output, got ")
+               << output_zp;
+      }
+    }
+  }
+
+  auto shiftTy = cast<ShapedType>(getShift().getType());
+  auto multiplierTy = cast<ShapedType>(getMultiplier().getType());
+
+  auto shiftETy = shiftTy.getElementType();
+  if (!shiftETy.isInteger(8)) {
+    return emitOpError("shift element type must be i8");
+  }
+
+  BoolAttr scale32Attr;
+  if ((getConstAttr(getScale32(), scale32Attr).failed())) {
+    return emitOpError("scale32 must be a constant boolean");
+  }
+
+  auto multiplierETy = multiplierTy.getElementType();
+  if (scale32Attr.getValue() && !multiplierETy.isInteger(32)) {
+    return emitOpError(
+               "expect i32 element type for multiplier for scale32=true, got ")
+           << multiplierETy;
+  }
+
+  if (!scale32Attr.getValue() && !multiplierETy.isInteger(16)) {
+    return emitOpError(
+               "expect i16 element type for multiplier for scale32=false, got ")
+           << multiplierETy;
+  }
+
+  IntegerAttr roundingModeAttr;
+  if ((getConstAttr(getRoundingMode(), roundingModeAttr).failed())) {
+    return emitOpError("rounding_mode must be a constant integer");
+  }
+
+  if (auto roundingMode = roundingModeAttr.getInt();
+      (roundingMode != 1 && roundingMode != 2 && roundingMode != 3)) {
+    return emitOpError(
+               "rounding mode must be an integer of value 1/2/3 "
+               "corresponding to SINGLE_ROUND/INEXACT_ROUND/DOUBLE_ROUND, got ")
+           << roundingMode;
+  }
+
+  BoolAttr perChannelAttr;
+  if ((getConstAttr(getPerChannel(), perChannelAttr).failed())) {
+    return emitOpError("per_channel must be a constant boolean");
+  }
+
+  // multiplier/shift must have shape = {numChannels},
+  // where numChannel is 1 if per_channel = false
+  // otherwise numChannel is dimension in input shape's last axis
+  int64_t numChannels = 1;
+  if (perChannelAttr.getValue()) {
+    ArrayRef<int64_t> inputShape = inputTy.getShape();
+    numChannels = inputTy.hasRank() ? inputShape[inputShape.size() - 1]
+                                    : ShapedType::kDynamic;
+  }
+
+  if (multiplierTy.hasRank() &&
+      multiplierTy.getShape()[0] != ShapedType::kDynamic &&
+      numChannels != ShapedType::kDynamic &&
+      multiplierTy.getShape()[0] != numChannels) {
+    return emitOpError("expect shape of { ")
+           << numChannels << " } for multiplier input, got { "
+           << multiplierTy.getShape()[0] << " }";
+  }
+
+  if (shiftTy.hasRank() && shiftTy.getShape()[0] != ShapedType::kDynamic &&
+      numChannels != ShapedType::kDynamic &&
+      shiftTy.getShape()[0] != numChannels) {
+    return emitOpError("expect shape of { ")
+           << numChannels << " } for shift input, got { "
+           << shiftTy.getShape()[0] << " }";
+  }
+
+  BoolAttr inputUnsignedAttr;
+  if ((getConstAttr(getInputUnsigned(), inputUnsignedAttr).failed())) {
+    return emitOpError("input_unsigned must be a constant boolean");
+  }
+
+  BoolAttr outputUnsignedAttr;
+  if ((getConstAttr(getOutputUnsigned(), outputUnsignedAttr).failed())) {
+    return emitOpError("output_unsigned must be a constant boolean");
+  }
+
+  if (inputETy.isInteger(8) || inputETy.isInteger(16) ||
+      inputETy.isInteger(32) || inputETy.isInteger(64)) {
+    if (outputETy.isInteger(8) || outputETy.isInteger(16) ||
+        outputETy.isInteger(32)) {
+      return success();
+    }
+  }
+
+  return emitOpError("input/output element types are incompatible: ")
+         << inputETy << " and " << outputETy;
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaReverseOp
+//===----------------------------------------------------------------------===//
+
+LogicalResult spirv::TosaReverseOp::verify() {
+  auto inputTy = cast<ShapedType>(getInput1().getType());
+  auto outputTy = cast<ShapedType>(getOutput().getType());
+
+  if (verifySameElementTypes(*this, inputTy, outputTy).failed()) {
+    return failure();
+  }
+
+  if (inputTy.getRank() != outputTy.getRank()) {
+    return emitOpError(
+        "expect output tensorARM rank to be equal to input rank");
+  }
+
+  IntegerAttr axisAttr;
+  if ((getConstAttr(getAxis(), axisAttr).failed())) {
+    return emitOpError("axis must be a constant integer");
+  }
+
+  int32_t reverseAxis = axisAttr.getInt();
+  if (reverseAxis < 0) {
+    return emitOpError("expected non-negative reverse axis");
+  }
+
+  if (inputTy.hasRank() && reverseAxis >= inputTy.getRank() &&
+      !(reverseAxis == 0 && inputTy.getRank() == 0)) {
+    return emitOpError("expect input rank (")
+           << inputTy.getRank() << ") to be larger than reverse axis ("
+           << reverseAxis << ")";
+  }
+
+  if (outputTy.hasRank() && reverseAxis >= outputTy.getRank() &&
+      !(reverseAxis == 0 && outputTy.getRank() == 0)) {
+    return emitOpError("expect output tensorARM rank (")
+           << outputTy.getRank() << ") to be larger than reverse axis ("
+           << reverseAxis << ")";
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaSelectOp
+//===----------------------------------------------------------------------===//
+LogicalResult spirv::TosaSelectOp::verify() {
+  if (verifySameElementTypes(*this, getInput2().getType(),
+                             getOutput().getType())
+          .failed()) {
+    return failure();
+  }
+  if (verifySameElementTypes(*this, getInput3().getType(),
+                             getOutput().getType())
+          .failed()) {
+    return failure();
+  }
+
+  auto predicateType = cast<ShapedType>(getInput1().getType());
+  if (!predicateType) {
+    emitOpError("expect shaped tensorARM for input1, got ")
+        << getInput1().getType();
+    return failure();
+  }
+
+  auto predicateElementType = predicateType.getElementType();
+  if (!predicateElementType.isInteger(1)) {
+    emitOpError("expect element type of bool for input1, got ")
+        << predicateElementType;
+    return failure();
+  }
+  return success();
+}
+
+//===----------------------------------------------------------------------===//
+// spirv.TosaReshapeOp
+//===----------------------------------------------------------------------===//
+
+mlir::LogicalResult spirv::TosaReshapeOp::verify() {
+  if (verifySameElementTypes(*this, getInput1().getType(),
+                             getOutput().getType())
+          .failed()) {
+    return failure();
+  }
+  ShapedType inputType = cast<ShapedType>(getInput1().getType());
+  ShapedType outputType = cast<ShapedType>(getType());
+
+  if (inputType.hasStaticShape() && outputType.hasStaticShape()) {
+    int64_t inputElementsNum = inputType.getNumElements();
+    int64_t outputElementsNum = outputType.getNumElements();
+    if (inputElementsNum != outputElementsNum) {
+      return emitOpError() << "Cannot reshape " << inputElementsNum
+                           << " elements into " << outputElementsNum;
+    }
+  }
+  return mlir::success();
+}
diff --git a/mlir/test/Dialect/SPIRV/Transforms/vce-deduction.mlir b/mlir/test/Dialect/SPIRV/Transforms/vce-deduction.mlir
index 7dab87f8081e..326137b50479 100644
--- a/mlir/test/Dialect/SPIRV/Transforms/vce-deduction.mlir
+++ b/mlir/test/Dialect/SPIRV/Transforms/vce-deduction.mlir
@@ -232,7 +232,7 @@ spirv.module Logical GLSL450 attributes {
   }
 }
 
-// CHECK: requires #spirv.vce<v1.5, [GraphARM, Int8, TensorsARM, Float16, VulkanMemoryModel], [SPV_ARM_graph, SPV_ARM_tensors, SPV_KHR_vulkan_memory_model]>
+// CHECK: requires #spirv.vce<v1.5, [GraphARM, Int8, TensorsARM, Float16, VulkanMemoryModel, Shader, Matrix], [SPV_ARM_graph, SPV_ARM_tensors, SPV_KHR_vulkan_memory_model]>
 spirv.module Logical Vulkan attributes {
   spirv.target_env = #spirv.target_env<
     #spirv.vce<v1.5, [VulkanMemoryModel, GraphARM, TensorsARM, Float16], [SPV_ARM_tensors, SPV_ARM_graph]>,
